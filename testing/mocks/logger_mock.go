// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/evg4b/uncors/internal/contracts.Logger -o logger_mock.go -n LoggerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoggerMock implements contracts.Logger
type LoggerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDebug          func(msg any, keyvals ...any)
	inspectFuncDebug   func(msg any, keyvals ...any)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcDebugf          func(template string, a ...any)
	inspectFuncDebugf   func(template string, a ...any)
	afterDebugfCounter  uint64
	beforeDebugfCounter uint64
	DebugfMock          mLoggerMockDebugf

	funcError          func(msg any, keyvals ...any)
	inspectFuncError   func(msg any, keyvals ...any)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcErrorf          func(template string, a ...any)
	inspectFuncErrorf   func(template string, a ...any)
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mLoggerMockErrorf

	funcInfo          func(msg any, keyvals ...any)
	inspectFuncInfo   func(msg any, keyvals ...any)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcInfof          func(template string, a ...any)
	inspectFuncInfof   func(template string, a ...any)
	afterInfofCounter  uint64
	beforeInfofCounter uint64
	InfofMock          mLoggerMockInfof

	funcPrint          func(msg any, keyvals ...any)
	inspectFuncPrint   func(msg any, keyvals ...any)
	afterPrintCounter  uint64
	beforePrintCounter uint64
	PrintMock          mLoggerMockPrint

	funcPrintf          func(format string, args ...any)
	inspectFuncPrintf   func(format string, args ...any)
	afterPrintfCounter  uint64
	beforePrintfCounter uint64
	PrintfMock          mLoggerMockPrintf

	funcWarn          func(msg any, keyvals ...any)
	inspectFuncWarn   func(msg any, keyvals ...any)
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerMockWarn

	funcWarnf          func(template string, a ...any)
	inspectFuncWarnf   func(template string, a ...any)
	afterWarnfCounter  uint64
	beforeWarnfCounter uint64
	WarnfMock          mLoggerMockWarnf
}

// NewLoggerMock returns a mock for contracts.Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.DebugfMock = mLoggerMockDebugf{mock: m}
	m.DebugfMock.callArgs = []*LoggerMockDebugfParams{}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.ErrorfMock = mLoggerMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*LoggerMockErrorfParams{}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.InfofMock = mLoggerMockInfof{mock: m}
	m.InfofMock.callArgs = []*LoggerMockInfofParams{}

	m.PrintMock = mLoggerMockPrint{mock: m}
	m.PrintMock.callArgs = []*LoggerMockPrintParams{}

	m.PrintfMock = mLoggerMockPrintf{mock: m}
	m.PrintfMock.callArgs = []*LoggerMockPrintfParams{}

	m.WarnMock = mLoggerMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerMockWarnParams{}

	m.WarnfMock = mLoggerMockWarnf{mock: m}
	m.WarnfMock.callArgs = []*LoggerMockWarnfParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerMockDebug struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockDebugParams
	paramPtrs *LoggerMockDebugParamPtrs

	Counter uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	msg     any
	keyvals []any
}

// LoggerMockDebugParamPtrs contains pointers to parameters of the Logger.Debug
type LoggerMockDebugParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebug *mLoggerMockDebug) Optional() *mLoggerMockDebug {
	mmDebug.optional = true
	return mmDebug
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(msg any, keyvals ...any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.paramPtrs != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by ExpectParams functions")
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{msg, keyvals}
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// ExpectMsgParam1 sets up expected param msg for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectMsgParam1(msg any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.msg = &msg

	return mmDebug
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.keyvals = &keyvals

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	return mmDebug.mock
}

// Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	return mmDebug.mock
}

// Times sets number of times Logger.Debug should be invoked
func (mmDebug *mLoggerMockDebug) Times(n uint64) *mLoggerMockDebug {
	if n == 0 {
		mmDebug.mock.t.Fatalf("Times of LoggerMock.Debug mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebug.expectedInvocations, n)
	return mmDebug
}

func (mmDebug *mLoggerMockDebug) invocationsDone() bool {
	if len(mmDebug.expectations) == 0 && mmDebug.defaultExpectation == nil && mmDebug.mock.funcDebug == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebug.mock.afterDebugCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebug.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debug implements contracts.Logger
func (mmDebug *LoggerMock) Debug(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(msg, keyvals...)
	}

	mm_params := LoggerMockDebugParams{msg, keyvals}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, &mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_want_ptrs := mmDebug.DebugMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter msg, want: %#v, got: %#v%s\n", *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter keyvals, want: %#v, got: %#v%s\n", *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(msg, keyvals...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v %v", msg, keyvals)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	if m.DebugMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugMock.invocationsDone()
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *e.params)
		}
	}

	afterDebugCounter := mm_atomic.LoadUint64(&m.afterDebugCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && afterDebugCounter < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debug")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && afterDebugCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Debug")
	}

	if !m.DebugMock.invocationsDone() && afterDebugCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debug but found %d calls",
			mm_atomic.LoadUint64(&m.DebugMock.expectedInvocations), afterDebugCounter)
	}
}

type mLoggerMockDebugf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugfExpectation
	expectations       []*LoggerMockDebugfExpectation

	callArgs []*LoggerMockDebugfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockDebugfExpectation specifies expectation struct of the Logger.Debugf
type LoggerMockDebugfExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockDebugfParams
	paramPtrs *LoggerMockDebugfParamPtrs

	Counter uint64
}

// LoggerMockDebugfParams contains parameters of the Logger.Debugf
type LoggerMockDebugfParams struct {
	template string
	a        []any
}

// LoggerMockDebugfParamPtrs contains pointers to parameters of the Logger.Debugf
type LoggerMockDebugfParamPtrs struct {
	template *string
	a        *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebugf *mLoggerMockDebugf) Optional() *mLoggerMockDebugf {
	mmDebugf.optional = true
	return mmDebugf
}

// Expect sets up expected params for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Expect(template string, a ...any) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.paramPtrs != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by ExpectParams functions")
	}

	mmDebugf.defaultExpectation.params = &LoggerMockDebugfParams{template, a}
	for _, e := range mmDebugf.expectations {
		if minimock.Equal(e.params, mmDebugf.defaultExpectation.params) {
			mmDebugf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugf.defaultExpectation.params)
		}
	}

	return mmDebugf
}

// ExpectTemplateParam1 sets up expected param template for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) ExpectTemplateParam1(template string) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.template = &template

	return mmDebugf
}

// ExpectAParam2 sets up expected param a for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) ExpectAParam2(a ...any) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.a = &a

	return mmDebugf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Inspect(f func(template string, a ...any)) *mLoggerMockDebugf {
	if mmDebugf.mock.inspectFuncDebugf != nil {
		mmDebugf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debugf")
	}

	mmDebugf.mock.inspectFuncDebugf = f

	return mmDebugf
}

// Return sets up results that will be returned by Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Return() *LoggerMock {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{mock: mmDebugf.mock}
	}

	return mmDebugf.mock
}

// Set uses given function f to mock the Logger.Debugf method
func (mmDebugf *mLoggerMockDebugf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmDebugf.defaultExpectation != nil {
		mmDebugf.mock.t.Fatalf("Default expectation is already set for the Logger.Debugf method")
	}

	if len(mmDebugf.expectations) > 0 {
		mmDebugf.mock.t.Fatalf("Some expectations are already set for the Logger.Debugf method")
	}

	mmDebugf.mock.funcDebugf = f
	return mmDebugf.mock
}

// Times sets number of times Logger.Debugf should be invoked
func (mmDebugf *mLoggerMockDebugf) Times(n uint64) *mLoggerMockDebugf {
	if n == 0 {
		mmDebugf.mock.t.Fatalf("Times of LoggerMock.Debugf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebugf.expectedInvocations, n)
	return mmDebugf
}

func (mmDebugf *mLoggerMockDebugf) invocationsDone() bool {
	if len(mmDebugf.expectations) == 0 && mmDebugf.defaultExpectation == nil && mmDebugf.mock.funcDebugf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebugf.mock.afterDebugfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebugf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debugf implements contracts.Logger
func (mmDebugf *LoggerMock) Debugf(template string, a ...any) {
	mm_atomic.AddUint64(&mmDebugf.beforeDebugfCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugf.afterDebugfCounter, 1)

	if mmDebugf.inspectFuncDebugf != nil {
		mmDebugf.inspectFuncDebugf(template, a...)
	}

	mm_params := LoggerMockDebugfParams{template, a}

	// Record call args
	mmDebugf.DebugfMock.mutex.Lock()
	mmDebugf.DebugfMock.callArgs = append(mmDebugf.DebugfMock.callArgs, &mm_params)
	mmDebugf.DebugfMock.mutex.Unlock()

	for _, e := range mmDebugf.DebugfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugf.DebugfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugf.DebugfMock.defaultExpectation.Counter, 1)
		mm_want := mmDebugf.DebugfMock.defaultExpectation.params
		mm_want_ptrs := mmDebugf.DebugfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugfParams{template, a}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.template != nil && !minimock.Equal(*mm_want_ptrs.template, mm_got.template) {
				mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameter template, want: %#v, got: %#v%s\n", *mm_want_ptrs.template, mm_got.template, minimock.Diff(*mm_want_ptrs.template, mm_got.template))
			}

			if mm_want_ptrs.a != nil && !minimock.Equal(*mm_want_ptrs.a, mm_got.a) {
				mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameter a, want: %#v, got: %#v%s\n", *mm_want_ptrs.a, mm_got.a, minimock.Diff(*mm_want_ptrs.a, mm_got.a))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebugf.funcDebugf != nil {
		mmDebugf.funcDebugf(template, a...)
		return
	}
	mmDebugf.t.Fatalf("Unexpected call to LoggerMock.Debugf. %v %v", template, a)

}

// DebugfAfterCounter returns a count of finished LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.afterDebugfCounter)
}

// DebugfBeforeCounter returns a count of LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.beforeDebugfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debugf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugf *mLoggerMockDebugf) Calls() []*LoggerMockDebugfParams {
	mmDebugf.mutex.RLock()

	argCopy := make([]*LoggerMockDebugfParams, len(mmDebugf.callArgs))
	copy(argCopy, mmDebugf.callArgs)

	mmDebugf.mutex.RUnlock()

	return argCopy
}

// MinimockDebugfDone returns true if the count of the Debugf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugfDone() bool {
	if m.DebugfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugfMock.invocationsDone()
}

// MinimockDebugfInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugfInspect() {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *e.params)
		}
	}

	afterDebugfCounter := mm_atomic.LoadUint64(&m.afterDebugfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && afterDebugfCounter < 1 {
		if m.DebugfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debugf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *m.DebugfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && afterDebugfCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Debugf")
	}

	if !m.DebugfMock.invocationsDone() && afterDebugfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debugf but found %d calls",
			mm_atomic.LoadUint64(&m.DebugfMock.expectedInvocations), afterDebugfCounter)
	}
}

type mLoggerMockError struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockErrorParams
	paramPtrs *LoggerMockErrorParamPtrs

	Counter uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	msg     any
	keyvals []any
}

// LoggerMockErrorParamPtrs contains pointers to parameters of the Logger.Error
type LoggerMockErrorParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmError *mLoggerMockError) Optional() *mLoggerMockError {
	mmError.optional = true
	return mmError
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(msg any, keyvals ...any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.paramPtrs != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by ExpectParams functions")
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{msg, keyvals}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// ExpectMsgParam1 sets up expected param msg for Logger.Error
func (mmError *mLoggerMockError) ExpectMsgParam1(msg any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.msg = &msg

	return mmError
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Error
func (mmError *mLoggerMockError) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.keyvals = &keyvals

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

// Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Times sets number of times Logger.Error should be invoked
func (mmError *mLoggerMockError) Times(n uint64) *mLoggerMockError {
	if n == 0 {
		mmError.mock.t.Fatalf("Times of LoggerMock.Error mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmError.expectedInvocations, n)
	return mmError
}

func (mmError *mLoggerMockError) invocationsDone() bool {
	if len(mmError.expectations) == 0 && mmError.defaultExpectation == nil && mmError.mock.funcError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmError.mock.afterErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Error implements contracts.Logger
func (mmError *LoggerMock) Error(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(msg, keyvals...)
	}

	mm_params := LoggerMockErrorParams{msg, keyvals}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, &mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_want_ptrs := mmError.ErrorMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter msg, want: %#v, got: %#v%s\n", *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter keyvals, want: %#v, got: %#v%s\n", *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(msg, keyvals...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v %v", msg, keyvals)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	if m.ErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorMock.invocationsDone()
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *e.params)
		}
	}

	afterErrorCounter := mm_atomic.LoadUint64(&m.afterErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && afterErrorCounter < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Error")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && afterErrorCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Error")
	}

	if !m.ErrorMock.invocationsDone() && afterErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Error but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorMock.expectedInvocations), afterErrorCounter)
	}
}

type mLoggerMockErrorf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorfExpectation
	expectations       []*LoggerMockErrorfExpectation

	callArgs []*LoggerMockErrorfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockErrorfExpectation specifies expectation struct of the Logger.Errorf
type LoggerMockErrorfExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockErrorfParams
	paramPtrs *LoggerMockErrorfParamPtrs

	Counter uint64
}

// LoggerMockErrorfParams contains parameters of the Logger.Errorf
type LoggerMockErrorfParams struct {
	template string
	a        []any
}

// LoggerMockErrorfParamPtrs contains pointers to parameters of the Logger.Errorf
type LoggerMockErrorfParamPtrs struct {
	template *string
	a        *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmErrorf *mLoggerMockErrorf) Optional() *mLoggerMockErrorf {
	mmErrorf.optional = true
	return mmErrorf
}

// Expect sets up expected params for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Expect(template string, a ...any) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.paramPtrs != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by ExpectParams functions")
	}

	mmErrorf.defaultExpectation.params = &LoggerMockErrorfParams{template, a}
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// ExpectTemplateParam1 sets up expected param template for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) ExpectTemplateParam1(template string) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.template = &template

	return mmErrorf
}

// ExpectAParam2 sets up expected param a for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) ExpectAParam2(a ...any) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.a = &a

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Inspect(f func(template string, a ...any)) *mLoggerMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Return() *LoggerMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{mock: mmErrorf.mock}
	}

	return mmErrorf.mock
}

// Set uses given function f to mock the Logger.Errorf method
func (mmErrorf *mLoggerMockErrorf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the Logger.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the Logger.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	return mmErrorf.mock
}

// Times sets number of times Logger.Errorf should be invoked
func (mmErrorf *mLoggerMockErrorf) Times(n uint64) *mLoggerMockErrorf {
	if n == 0 {
		mmErrorf.mock.t.Fatalf("Times of LoggerMock.Errorf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmErrorf.expectedInvocations, n)
	return mmErrorf
}

func (mmErrorf *mLoggerMockErrorf) invocationsDone() bool {
	if len(mmErrorf.expectations) == 0 && mmErrorf.defaultExpectation == nil && mmErrorf.mock.funcErrorf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmErrorf.mock.afterErrorfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmErrorf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Errorf implements contracts.Logger
func (mmErrorf *LoggerMock) Errorf(template string, a ...any) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(template, a...)
	}

	mm_params := LoggerMockErrorfParams{template, a}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, &mm_params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorf.ErrorfMock.defaultExpectation.params
		mm_want_ptrs := mmErrorf.ErrorfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorfParams{template, a}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.template != nil && !minimock.Equal(*mm_want_ptrs.template, mm_got.template) {
				mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameter template, want: %#v, got: %#v%s\n", *mm_want_ptrs.template, mm_got.template, minimock.Diff(*mm_want_ptrs.template, mm_got.template))
			}

			if mm_want_ptrs.a != nil && !minimock.Equal(*mm_want_ptrs.a, mm_got.a) {
				mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameter a, want: %#v, got: %#v%s\n", *mm_want_ptrs.a, mm_got.a, minimock.Diff(*mm_want_ptrs.a, mm_got.a))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(template, a...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to LoggerMock.Errorf. %v %v", template, a)

}

// ErrorfAfterCounter returns a count of finished LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mLoggerMockErrorf) Calls() []*LoggerMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*LoggerMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorfDone() bool {
	if m.ErrorfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorfMock.invocationsDone()
}

// MinimockErrorfInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *e.params)
		}
	}

	afterErrorfCounter := mm_atomic.LoadUint64(&m.afterErrorfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && afterErrorfCounter < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Errorf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && afterErrorfCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Errorf")
	}

	if !m.ErrorfMock.invocationsDone() && afterErrorfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Errorf but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorfMock.expectedInvocations), afterErrorfCounter)
	}
}

type mLoggerMockInfo struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockInfoParams
	paramPtrs *LoggerMockInfoParamPtrs

	Counter uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	msg     any
	keyvals []any
}

// LoggerMockInfoParamPtrs contains pointers to parameters of the Logger.Info
type LoggerMockInfoParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfo *mLoggerMockInfo) Optional() *mLoggerMockInfo {
	mmInfo.optional = true
	return mmInfo
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(msg any, keyvals ...any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.paramPtrs != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by ExpectParams functions")
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{msg, keyvals}
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// ExpectMsgParam1 sets up expected param msg for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectMsgParam1(msg any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.msg = &msg

	return mmInfo
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.keyvals = &keyvals

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	return mmInfo.mock
}

// Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	return mmInfo.mock
}

// Times sets number of times Logger.Info should be invoked
func (mmInfo *mLoggerMockInfo) Times(n uint64) *mLoggerMockInfo {
	if n == 0 {
		mmInfo.mock.t.Fatalf("Times of LoggerMock.Info mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfo.expectedInvocations, n)
	return mmInfo
}

func (mmInfo *mLoggerMockInfo) invocationsDone() bool {
	if len(mmInfo.expectations) == 0 && mmInfo.defaultExpectation == nil && mmInfo.mock.funcInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfo.mock.afterInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Info implements contracts.Logger
func (mmInfo *LoggerMock) Info(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(msg, keyvals...)
	}

	mm_params := LoggerMockInfoParams{msg, keyvals}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, &mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_want_ptrs := mmInfo.InfoMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfoParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter msg, want: %#v, got: %#v%s\n", *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter keyvals, want: %#v, got: %#v%s\n", *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(msg, keyvals...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v %v", msg, keyvals)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	if m.InfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfoMock.invocationsDone()
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *e.params)
		}
	}

	afterInfoCounter := mm_atomic.LoadUint64(&m.afterInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && afterInfoCounter < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Info")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && afterInfoCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Info")
	}

	if !m.InfoMock.invocationsDone() && afterInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Info but found %d calls",
			mm_atomic.LoadUint64(&m.InfoMock.expectedInvocations), afterInfoCounter)
	}
}

type mLoggerMockInfof struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfofExpectation
	expectations       []*LoggerMockInfofExpectation

	callArgs []*LoggerMockInfofParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockInfofExpectation specifies expectation struct of the Logger.Infof
type LoggerMockInfofExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockInfofParams
	paramPtrs *LoggerMockInfofParamPtrs

	Counter uint64
}

// LoggerMockInfofParams contains parameters of the Logger.Infof
type LoggerMockInfofParams struct {
	template string
	a        []any
}

// LoggerMockInfofParamPtrs contains pointers to parameters of the Logger.Infof
type LoggerMockInfofParamPtrs struct {
	template *string
	a        *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfof *mLoggerMockInfof) Optional() *mLoggerMockInfof {
	mmInfof.optional = true
	return mmInfof
}

// Expect sets up expected params for Logger.Infof
func (mmInfof *mLoggerMockInfof) Expect(template string, a ...any) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.paramPtrs != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by ExpectParams functions")
	}

	mmInfof.defaultExpectation.params = &LoggerMockInfofParams{template, a}
	for _, e := range mmInfof.expectations {
		if minimock.Equal(e.params, mmInfof.defaultExpectation.params) {
			mmInfof.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfof.defaultExpectation.params)
		}
	}

	return mmInfof
}

// ExpectTemplateParam1 sets up expected param template for Logger.Infof
func (mmInfof *mLoggerMockInfof) ExpectTemplateParam1(template string) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.template = &template

	return mmInfof
}

// ExpectAParam2 sets up expected param a for Logger.Infof
func (mmInfof *mLoggerMockInfof) ExpectAParam2(a ...any) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.a = &a

	return mmInfof
}

// Inspect accepts an inspector function that has same arguments as the Logger.Infof
func (mmInfof *mLoggerMockInfof) Inspect(f func(template string, a ...any)) *mLoggerMockInfof {
	if mmInfof.mock.inspectFuncInfof != nil {
		mmInfof.mock.t.Fatalf("Inspect function is already set for LoggerMock.Infof")
	}

	mmInfof.mock.inspectFuncInfof = f

	return mmInfof
}

// Return sets up results that will be returned by Logger.Infof
func (mmInfof *mLoggerMockInfof) Return() *LoggerMock {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{mock: mmInfof.mock}
	}

	return mmInfof.mock
}

// Set uses given function f to mock the Logger.Infof method
func (mmInfof *mLoggerMockInfof) Set(f func(template string, a ...any)) *LoggerMock {
	if mmInfof.defaultExpectation != nil {
		mmInfof.mock.t.Fatalf("Default expectation is already set for the Logger.Infof method")
	}

	if len(mmInfof.expectations) > 0 {
		mmInfof.mock.t.Fatalf("Some expectations are already set for the Logger.Infof method")
	}

	mmInfof.mock.funcInfof = f
	return mmInfof.mock
}

// Times sets number of times Logger.Infof should be invoked
func (mmInfof *mLoggerMockInfof) Times(n uint64) *mLoggerMockInfof {
	if n == 0 {
		mmInfof.mock.t.Fatalf("Times of LoggerMock.Infof mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfof.expectedInvocations, n)
	return mmInfof
}

func (mmInfof *mLoggerMockInfof) invocationsDone() bool {
	if len(mmInfof.expectations) == 0 && mmInfof.defaultExpectation == nil && mmInfof.mock.funcInfof == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfof.mock.afterInfofCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfof.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Infof implements contracts.Logger
func (mmInfof *LoggerMock) Infof(template string, a ...any) {
	mm_atomic.AddUint64(&mmInfof.beforeInfofCounter, 1)
	defer mm_atomic.AddUint64(&mmInfof.afterInfofCounter, 1)

	if mmInfof.inspectFuncInfof != nil {
		mmInfof.inspectFuncInfof(template, a...)
	}

	mm_params := LoggerMockInfofParams{template, a}

	// Record call args
	mmInfof.InfofMock.mutex.Lock()
	mmInfof.InfofMock.callArgs = append(mmInfof.InfofMock.callArgs, &mm_params)
	mmInfof.InfofMock.mutex.Unlock()

	for _, e := range mmInfof.InfofMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfof.InfofMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfof.InfofMock.defaultExpectation.Counter, 1)
		mm_want := mmInfof.InfofMock.defaultExpectation.params
		mm_want_ptrs := mmInfof.InfofMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfofParams{template, a}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.template != nil && !minimock.Equal(*mm_want_ptrs.template, mm_got.template) {
				mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameter template, want: %#v, got: %#v%s\n", *mm_want_ptrs.template, mm_got.template, minimock.Diff(*mm_want_ptrs.template, mm_got.template))
			}

			if mm_want_ptrs.a != nil && !minimock.Equal(*mm_want_ptrs.a, mm_got.a) {
				mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameter a, want: %#v, got: %#v%s\n", *mm_want_ptrs.a, mm_got.a, minimock.Diff(*mm_want_ptrs.a, mm_got.a))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfof.funcInfof != nil {
		mmInfof.funcInfof(template, a...)
		return
	}
	mmInfof.t.Fatalf("Unexpected call to LoggerMock.Infof. %v %v", template, a)

}

// InfofAfterCounter returns a count of finished LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.afterInfofCounter)
}

// InfofBeforeCounter returns a count of LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.beforeInfofCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Infof.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfof *mLoggerMockInfof) Calls() []*LoggerMockInfofParams {
	mmInfof.mutex.RLock()

	argCopy := make([]*LoggerMockInfofParams, len(mmInfof.callArgs))
	copy(argCopy, mmInfof.callArgs)

	mmInfof.mutex.RUnlock()

	return argCopy
}

// MinimockInfofDone returns true if the count of the Infof invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfofDone() bool {
	if m.InfofMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfofMock.invocationsDone()
}

// MinimockInfofInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfofInspect() {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *e.params)
		}
	}

	afterInfofCounter := mm_atomic.LoadUint64(&m.afterInfofCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && afterInfofCounter < 1 {
		if m.InfofMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Infof")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *m.InfofMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && afterInfofCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Infof")
	}

	if !m.InfofMock.invocationsDone() && afterInfofCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Infof but found %d calls",
			mm_atomic.LoadUint64(&m.InfofMock.expectedInvocations), afterInfofCounter)
	}
}

type mLoggerMockPrint struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockPrintExpectation
	expectations       []*LoggerMockPrintExpectation

	callArgs []*LoggerMockPrintParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockPrintExpectation specifies expectation struct of the Logger.Print
type LoggerMockPrintExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockPrintParams
	paramPtrs *LoggerMockPrintParamPtrs

	Counter uint64
}

// LoggerMockPrintParams contains parameters of the Logger.Print
type LoggerMockPrintParams struct {
	msg     any
	keyvals []any
}

// LoggerMockPrintParamPtrs contains pointers to parameters of the Logger.Print
type LoggerMockPrintParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrint *mLoggerMockPrint) Optional() *mLoggerMockPrint {
	mmPrint.optional = true
	return mmPrint
}

// Expect sets up expected params for Logger.Print
func (mmPrint *mLoggerMockPrint) Expect(msg any, keyvals ...any) *mLoggerMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.paramPtrs != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by ExpectParams functions")
	}

	mmPrint.defaultExpectation.params = &LoggerMockPrintParams{msg, keyvals}
	for _, e := range mmPrint.expectations {
		if minimock.Equal(e.params, mmPrint.defaultExpectation.params) {
			mmPrint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrint.defaultExpectation.params)
		}
	}

	return mmPrint
}

// ExpectMsgParam1 sets up expected param msg for Logger.Print
func (mmPrint *mLoggerMockPrint) ExpectMsgParam1(msg any) *mLoggerMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.params != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Expect")
	}

	if mmPrint.defaultExpectation.paramPtrs == nil {
		mmPrint.defaultExpectation.paramPtrs = &LoggerMockPrintParamPtrs{}
	}
	mmPrint.defaultExpectation.paramPtrs.msg = &msg

	return mmPrint
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Print
func (mmPrint *mLoggerMockPrint) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.params != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Expect")
	}

	if mmPrint.defaultExpectation.paramPtrs == nil {
		mmPrint.defaultExpectation.paramPtrs = &LoggerMockPrintParamPtrs{}
	}
	mmPrint.defaultExpectation.paramPtrs.keyvals = &keyvals

	return mmPrint
}

// Inspect accepts an inspector function that has same arguments as the Logger.Print
func (mmPrint *mLoggerMockPrint) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockPrint {
	if mmPrint.mock.inspectFuncPrint != nil {
		mmPrint.mock.t.Fatalf("Inspect function is already set for LoggerMock.Print")
	}

	mmPrint.mock.inspectFuncPrint = f

	return mmPrint
}

// Return sets up results that will be returned by Logger.Print
func (mmPrint *mLoggerMockPrint) Return() *LoggerMock {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{mock: mmPrint.mock}
	}

	return mmPrint.mock
}

// Set uses given function f to mock the Logger.Print method
func (mmPrint *mLoggerMockPrint) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmPrint.defaultExpectation != nil {
		mmPrint.mock.t.Fatalf("Default expectation is already set for the Logger.Print method")
	}

	if len(mmPrint.expectations) > 0 {
		mmPrint.mock.t.Fatalf("Some expectations are already set for the Logger.Print method")
	}

	mmPrint.mock.funcPrint = f
	return mmPrint.mock
}

// Times sets number of times Logger.Print should be invoked
func (mmPrint *mLoggerMockPrint) Times(n uint64) *mLoggerMockPrint {
	if n == 0 {
		mmPrint.mock.t.Fatalf("Times of LoggerMock.Print mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrint.expectedInvocations, n)
	return mmPrint
}

func (mmPrint *mLoggerMockPrint) invocationsDone() bool {
	if len(mmPrint.expectations) == 0 && mmPrint.defaultExpectation == nil && mmPrint.mock.funcPrint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrint.mock.afterPrintCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Print implements contracts.Logger
func (mmPrint *LoggerMock) Print(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmPrint.beforePrintCounter, 1)
	defer mm_atomic.AddUint64(&mmPrint.afterPrintCounter, 1)

	if mmPrint.inspectFuncPrint != nil {
		mmPrint.inspectFuncPrint(msg, keyvals...)
	}

	mm_params := LoggerMockPrintParams{msg, keyvals}

	// Record call args
	mmPrint.PrintMock.mutex.Lock()
	mmPrint.PrintMock.callArgs = append(mmPrint.PrintMock.callArgs, &mm_params)
	mmPrint.PrintMock.mutex.Unlock()

	for _, e := range mmPrint.PrintMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrint.PrintMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrint.PrintMock.defaultExpectation.Counter, 1)
		mm_want := mmPrint.PrintMock.defaultExpectation.params
		mm_want_ptrs := mmPrint.PrintMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockPrintParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmPrint.t.Errorf("LoggerMock.Print got unexpected parameter msg, want: %#v, got: %#v%s\n", *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmPrint.t.Errorf("LoggerMock.Print got unexpected parameter keyvals, want: %#v, got: %#v%s\n", *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrint.t.Errorf("LoggerMock.Print got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrint.funcPrint != nil {
		mmPrint.funcPrint(msg, keyvals...)
		return
	}
	mmPrint.t.Fatalf("Unexpected call to LoggerMock.Print. %v %v", msg, keyvals)

}

// PrintAfterCounter returns a count of finished LoggerMock.Print invocations
func (mmPrint *LoggerMock) PrintAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.afterPrintCounter)
}

// PrintBeforeCounter returns a count of LoggerMock.Print invocations
func (mmPrint *LoggerMock) PrintBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.beforePrintCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Print.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrint *mLoggerMockPrint) Calls() []*LoggerMockPrintParams {
	mmPrint.mutex.RLock()

	argCopy := make([]*LoggerMockPrintParams, len(mmPrint.callArgs))
	copy(argCopy, mmPrint.callArgs)

	mmPrint.mutex.RUnlock()

	return argCopy
}

// MinimockPrintDone returns true if the count of the Print invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPrintDone() bool {
	if m.PrintMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintMock.invocationsDone()
}

// MinimockPrintInspect logs each unmet expectation
func (m *LoggerMock) MinimockPrintInspect() {
	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Print with params: %#v", *e.params)
		}
	}

	afterPrintCounter := mm_atomic.LoadUint64(&m.afterPrintCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintMock.defaultExpectation != nil && afterPrintCounter < 1 {
		if m.PrintMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Print")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Print with params: %#v", *m.PrintMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrint != nil && afterPrintCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Print")
	}

	if !m.PrintMock.invocationsDone() && afterPrintCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Print but found %d calls",
			mm_atomic.LoadUint64(&m.PrintMock.expectedInvocations), afterPrintCounter)
	}
}

type mLoggerMockPrintf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockPrintfExpectation
	expectations       []*LoggerMockPrintfExpectation

	callArgs []*LoggerMockPrintfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockPrintfExpectation specifies expectation struct of the Logger.Printf
type LoggerMockPrintfExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockPrintfParams
	paramPtrs *LoggerMockPrintfParamPtrs

	Counter uint64
}

// LoggerMockPrintfParams contains parameters of the Logger.Printf
type LoggerMockPrintfParams struct {
	format string
	args   []any
}

// LoggerMockPrintfParamPtrs contains pointers to parameters of the Logger.Printf
type LoggerMockPrintfParamPtrs struct {
	format *string
	args   *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintf *mLoggerMockPrintf) Optional() *mLoggerMockPrintf {
	mmPrintf.optional = true
	return mmPrintf
}

// Expect sets up expected params for Logger.Printf
func (mmPrintf *mLoggerMockPrintf) Expect(format string, args ...any) *mLoggerMockPrintf {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{}
	}

	if mmPrintf.defaultExpectation.paramPtrs != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by ExpectParams functions")
	}

	mmPrintf.defaultExpectation.params = &LoggerMockPrintfParams{format, args}
	for _, e := range mmPrintf.expectations {
		if minimock.Equal(e.params, mmPrintf.defaultExpectation.params) {
			mmPrintf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintf.defaultExpectation.params)
		}
	}

	return mmPrintf
}

// ExpectFormatParam1 sets up expected param format for Logger.Printf
func (mmPrintf *mLoggerMockPrintf) ExpectFormatParam1(format string) *mLoggerMockPrintf {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{}
	}

	if mmPrintf.defaultExpectation.params != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Expect")
	}

	if mmPrintf.defaultExpectation.paramPtrs == nil {
		mmPrintf.defaultExpectation.paramPtrs = &LoggerMockPrintfParamPtrs{}
	}
	mmPrintf.defaultExpectation.paramPtrs.format = &format

	return mmPrintf
}

// ExpectArgsParam2 sets up expected param args for Logger.Printf
func (mmPrintf *mLoggerMockPrintf) ExpectArgsParam2(args ...any) *mLoggerMockPrintf {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{}
	}

	if mmPrintf.defaultExpectation.params != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Expect")
	}

	if mmPrintf.defaultExpectation.paramPtrs == nil {
		mmPrintf.defaultExpectation.paramPtrs = &LoggerMockPrintfParamPtrs{}
	}
	mmPrintf.defaultExpectation.paramPtrs.args = &args

	return mmPrintf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Printf
func (mmPrintf *mLoggerMockPrintf) Inspect(f func(format string, args ...any)) *mLoggerMockPrintf {
	if mmPrintf.mock.inspectFuncPrintf != nil {
		mmPrintf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Printf")
	}

	mmPrintf.mock.inspectFuncPrintf = f

	return mmPrintf
}

// Return sets up results that will be returned by Logger.Printf
func (mmPrintf *mLoggerMockPrintf) Return() *LoggerMock {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{mock: mmPrintf.mock}
	}

	return mmPrintf.mock
}

// Set uses given function f to mock the Logger.Printf method
func (mmPrintf *mLoggerMockPrintf) Set(f func(format string, args ...any)) *LoggerMock {
	if mmPrintf.defaultExpectation != nil {
		mmPrintf.mock.t.Fatalf("Default expectation is already set for the Logger.Printf method")
	}

	if len(mmPrintf.expectations) > 0 {
		mmPrintf.mock.t.Fatalf("Some expectations are already set for the Logger.Printf method")
	}

	mmPrintf.mock.funcPrintf = f
	return mmPrintf.mock
}

// Times sets number of times Logger.Printf should be invoked
func (mmPrintf *mLoggerMockPrintf) Times(n uint64) *mLoggerMockPrintf {
	if n == 0 {
		mmPrintf.mock.t.Fatalf("Times of LoggerMock.Printf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintf.expectedInvocations, n)
	return mmPrintf
}

func (mmPrintf *mLoggerMockPrintf) invocationsDone() bool {
	if len(mmPrintf.expectations) == 0 && mmPrintf.defaultExpectation == nil && mmPrintf.mock.funcPrintf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintf.mock.afterPrintfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Printf implements contracts.Logger
func (mmPrintf *LoggerMock) Printf(format string, args ...any) {
	mm_atomic.AddUint64(&mmPrintf.beforePrintfCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintf.afterPrintfCounter, 1)

	if mmPrintf.inspectFuncPrintf != nil {
		mmPrintf.inspectFuncPrintf(format, args...)
	}

	mm_params := LoggerMockPrintfParams{format, args}

	// Record call args
	mmPrintf.PrintfMock.mutex.Lock()
	mmPrintf.PrintfMock.callArgs = append(mmPrintf.PrintfMock.callArgs, &mm_params)
	mmPrintf.PrintfMock.mutex.Unlock()

	for _, e := range mmPrintf.PrintfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrintf.PrintfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintf.PrintfMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintf.PrintfMock.defaultExpectation.params
		mm_want_ptrs := mmPrintf.PrintfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockPrintfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmPrintf.t.Errorf("LoggerMock.Printf got unexpected parameter format, want: %#v, got: %#v%s\n", *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmPrintf.t.Errorf("LoggerMock.Printf got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintf.t.Errorf("LoggerMock.Printf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrintf.funcPrintf != nil {
		mmPrintf.funcPrintf(format, args...)
		return
	}
	mmPrintf.t.Fatalf("Unexpected call to LoggerMock.Printf. %v %v", format, args)

}

// PrintfAfterCounter returns a count of finished LoggerMock.Printf invocations
func (mmPrintf *LoggerMock) PrintfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintf.afterPrintfCounter)
}

// PrintfBeforeCounter returns a count of LoggerMock.Printf invocations
func (mmPrintf *LoggerMock) PrintfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintf.beforePrintfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Printf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintf *mLoggerMockPrintf) Calls() []*LoggerMockPrintfParams {
	mmPrintf.mutex.RLock()

	argCopy := make([]*LoggerMockPrintfParams, len(mmPrintf.callArgs))
	copy(argCopy, mmPrintf.callArgs)

	mmPrintf.mutex.RUnlock()

	return argCopy
}

// MinimockPrintfDone returns true if the count of the Printf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPrintfDone() bool {
	if m.PrintfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintfMock.invocationsDone()
}

// MinimockPrintfInspect logs each unmet expectation
func (m *LoggerMock) MinimockPrintfInspect() {
	for _, e := range m.PrintfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Printf with params: %#v", *e.params)
		}
	}

	afterPrintfCounter := mm_atomic.LoadUint64(&m.afterPrintfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintfMock.defaultExpectation != nil && afterPrintfCounter < 1 {
		if m.PrintfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Printf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Printf with params: %#v", *m.PrintfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintf != nil && afterPrintfCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Printf")
	}

	if !m.PrintfMock.invocationsDone() && afterPrintfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Printf but found %d calls",
			mm_atomic.LoadUint64(&m.PrintfMock.expectedInvocations), afterPrintfCounter)
	}
}

type mLoggerMockWarn struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnExpectation
	expectations       []*LoggerMockWarnExpectation

	callArgs []*LoggerMockWarnParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockWarnExpectation specifies expectation struct of the Logger.Warn
type LoggerMockWarnExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockWarnParams
	paramPtrs *LoggerMockWarnParamPtrs

	Counter uint64
}

// LoggerMockWarnParams contains parameters of the Logger.Warn
type LoggerMockWarnParams struct {
	msg     any
	keyvals []any
}

// LoggerMockWarnParamPtrs contains pointers to parameters of the Logger.Warn
type LoggerMockWarnParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarn *mLoggerMockWarn) Optional() *mLoggerMockWarn {
	mmWarn.optional = true
	return mmWarn
}

// Expect sets up expected params for Logger.Warn
func (mmWarn *mLoggerMockWarn) Expect(msg any, keyvals ...any) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.paramPtrs != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by ExpectParams functions")
	}

	mmWarn.defaultExpectation.params = &LoggerMockWarnParams{msg, keyvals}
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// ExpectMsgParam1 sets up expected param msg for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectMsgParam1(msg any) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.msg = &msg

	return mmWarn
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.keyvals = &keyvals

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warn
func (mmWarn *mLoggerMockWarn) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Logger.Warn
func (mmWarn *mLoggerMockWarn) Return() *LoggerMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{mock: mmWarn.mock}
	}

	return mmWarn.mock
}

// Set uses given function f to mock the Logger.Warn method
func (mmWarn *mLoggerMockWarn) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Logger.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Logger.Warn method")
	}

	mmWarn.mock.funcWarn = f
	return mmWarn.mock
}

// Times sets number of times Logger.Warn should be invoked
func (mmWarn *mLoggerMockWarn) Times(n uint64) *mLoggerMockWarn {
	if n == 0 {
		mmWarn.mock.t.Fatalf("Times of LoggerMock.Warn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarn.expectedInvocations, n)
	return mmWarn
}

func (mmWarn *mLoggerMockWarn) invocationsDone() bool {
	if len(mmWarn.expectations) == 0 && mmWarn.defaultExpectation == nil && mmWarn.mock.funcWarn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarn.mock.afterWarnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warn implements contracts.Logger
func (mmWarn *LoggerMock) Warn(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(msg, keyvals...)
	}

	mm_params := LoggerMockWarnParams{msg, keyvals}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, &mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_want_ptrs := mmWarn.WarnMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter msg, want: %#v, got: %#v%s\n", *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter keyvals, want: %#v, got: %#v%s\n", *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(msg, keyvals...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerMock.Warn. %v %v", msg, keyvals)

}

// WarnAfterCounter returns a count of finished LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerMockWarn) Calls() []*LoggerMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnDone() bool {
	if m.WarnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnMock.invocationsDone()
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *e.params)
		}
	}

	afterWarnCounter := mm_atomic.LoadUint64(&m.afterWarnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && afterWarnCounter < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warn")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && afterWarnCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Warn")
	}

	if !m.WarnMock.invocationsDone() && afterWarnCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warn but found %d calls",
			mm_atomic.LoadUint64(&m.WarnMock.expectedInvocations), afterWarnCounter)
	}
}

type mLoggerMockWarnf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnfExpectation
	expectations       []*LoggerMockWarnfExpectation

	callArgs []*LoggerMockWarnfParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LoggerMockWarnfExpectation specifies expectation struct of the Logger.Warnf
type LoggerMockWarnfExpectation struct {
	mock      *LoggerMock
	params    *LoggerMockWarnfParams
	paramPtrs *LoggerMockWarnfParamPtrs

	Counter uint64
}

// LoggerMockWarnfParams contains parameters of the Logger.Warnf
type LoggerMockWarnfParams struct {
	template string
	a        []any
}

// LoggerMockWarnfParamPtrs contains pointers to parameters of the Logger.Warnf
type LoggerMockWarnfParamPtrs struct {
	template *string
	a        *[]any
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarnf *mLoggerMockWarnf) Optional() *mLoggerMockWarnf {
	mmWarnf.optional = true
	return mmWarnf
}

// Expect sets up expected params for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Expect(template string, a ...any) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.paramPtrs != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by ExpectParams functions")
	}

	mmWarnf.defaultExpectation.params = &LoggerMockWarnfParams{template, a}
	for _, e := range mmWarnf.expectations {
		if minimock.Equal(e.params, mmWarnf.defaultExpectation.params) {
			mmWarnf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarnf.defaultExpectation.params)
		}
	}

	return mmWarnf
}

// ExpectTemplateParam1 sets up expected param template for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) ExpectTemplateParam1(template string) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.template = &template

	return mmWarnf
}

// ExpectAParam2 sets up expected param a for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) ExpectAParam2(a ...any) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.a = &a

	return mmWarnf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Inspect(f func(template string, a ...any)) *mLoggerMockWarnf {
	if mmWarnf.mock.inspectFuncWarnf != nil {
		mmWarnf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warnf")
	}

	mmWarnf.mock.inspectFuncWarnf = f

	return mmWarnf
}

// Return sets up results that will be returned by Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Return() *LoggerMock {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{mock: mmWarnf.mock}
	}

	return mmWarnf.mock
}

// Set uses given function f to mock the Logger.Warnf method
func (mmWarnf *mLoggerMockWarnf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmWarnf.defaultExpectation != nil {
		mmWarnf.mock.t.Fatalf("Default expectation is already set for the Logger.Warnf method")
	}

	if len(mmWarnf.expectations) > 0 {
		mmWarnf.mock.t.Fatalf("Some expectations are already set for the Logger.Warnf method")
	}

	mmWarnf.mock.funcWarnf = f
	return mmWarnf.mock
}

// Times sets number of times Logger.Warnf should be invoked
func (mmWarnf *mLoggerMockWarnf) Times(n uint64) *mLoggerMockWarnf {
	if n == 0 {
		mmWarnf.mock.t.Fatalf("Times of LoggerMock.Warnf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarnf.expectedInvocations, n)
	return mmWarnf
}

func (mmWarnf *mLoggerMockWarnf) invocationsDone() bool {
	if len(mmWarnf.expectations) == 0 && mmWarnf.defaultExpectation == nil && mmWarnf.mock.funcWarnf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarnf.mock.afterWarnfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarnf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warnf implements contracts.Logger
func (mmWarnf *LoggerMock) Warnf(template string, a ...any) {
	mm_atomic.AddUint64(&mmWarnf.beforeWarnfCounter, 1)
	defer mm_atomic.AddUint64(&mmWarnf.afterWarnfCounter, 1)

	if mmWarnf.inspectFuncWarnf != nil {
		mmWarnf.inspectFuncWarnf(template, a...)
	}

	mm_params := LoggerMockWarnfParams{template, a}

	// Record call args
	mmWarnf.WarnfMock.mutex.Lock()
	mmWarnf.WarnfMock.callArgs = append(mmWarnf.WarnfMock.callArgs, &mm_params)
	mmWarnf.WarnfMock.mutex.Unlock()

	for _, e := range mmWarnf.WarnfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarnf.WarnfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarnf.WarnfMock.defaultExpectation.Counter, 1)
		mm_want := mmWarnf.WarnfMock.defaultExpectation.params
		mm_want_ptrs := mmWarnf.WarnfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnfParams{template, a}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.template != nil && !minimock.Equal(*mm_want_ptrs.template, mm_got.template) {
				mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameter template, want: %#v, got: %#v%s\n", *mm_want_ptrs.template, mm_got.template, minimock.Diff(*mm_want_ptrs.template, mm_got.template))
			}

			if mm_want_ptrs.a != nil && !minimock.Equal(*mm_want_ptrs.a, mm_got.a) {
				mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameter a, want: %#v, got: %#v%s\n", *mm_want_ptrs.a, mm_got.a, minimock.Diff(*mm_want_ptrs.a, mm_got.a))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarnf.funcWarnf != nil {
		mmWarnf.funcWarnf(template, a...)
		return
	}
	mmWarnf.t.Fatalf("Unexpected call to LoggerMock.Warnf. %v %v", template, a)

}

// WarnfAfterCounter returns a count of finished LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.afterWarnfCounter)
}

// WarnfBeforeCounter returns a count of LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.beforeWarnfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warnf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarnf *mLoggerMockWarnf) Calls() []*LoggerMockWarnfParams {
	mmWarnf.mutex.RLock()

	argCopy := make([]*LoggerMockWarnfParams, len(mmWarnf.callArgs))
	copy(argCopy, mmWarnf.callArgs)

	mmWarnf.mutex.RUnlock()

	return argCopy
}

// MinimockWarnfDone returns true if the count of the Warnf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnfDone() bool {
	if m.WarnfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnfMock.invocationsDone()
}

// MinimockWarnfInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnfInspect() {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *e.params)
		}
	}

	afterWarnfCounter := mm_atomic.LoadUint64(&m.afterWarnfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && afterWarnfCounter < 1 {
		if m.WarnfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warnf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *m.WarnfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && afterWarnfCounter < 1 {
		m.t.Error("Expected call to LoggerMock.Warnf")
	}

	if !m.WarnfMock.invocationsDone() && afterWarnfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warnf but found %d calls",
			mm_atomic.LoadUint64(&m.WarnfMock.expectedInvocations), afterWarnfCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDebugInspect()

			m.MinimockDebugfInspect()

			m.MinimockErrorInspect()

			m.MinimockErrorfInspect()

			m.MinimockInfoInspect()

			m.MinimockInfofInspect()

			m.MinimockPrintInspect()

			m.MinimockPrintfInspect()

			m.MinimockWarnInspect()

			m.MinimockWarnfInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockDebugfDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockInfoDone() &&
		m.MinimockInfofDone() &&
		m.MinimockPrintDone() &&
		m.MinimockPrintfDone() &&
		m.MinimockWarnDone() &&
		m.MinimockWarnfDone()
}
