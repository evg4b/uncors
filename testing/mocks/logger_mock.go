package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/evg4b/uncors/internal/contracts.Logger -o ./logger_mock.go -n LoggerMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_contracts "github.com/evg4b/uncors/internal/contracts"
	"github.com/gojuno/minimock/v3"
)

// LoggerMock implements contracts.Logger
type LoggerMock struct {
	t minimock.Tester

	funcDebug          func(a ...any)
	inspectFuncDebug   func(a ...any)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcDebugf          func(template string, a ...any)
	inspectFuncDebugf   func(template string, a ...any)
	afterDebugfCounter  uint64
	beforeDebugfCounter uint64
	DebugfMock          mLoggerMockDebugf

	funcError          func(a ...any)
	inspectFuncError   func(a ...any)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcErrorf          func(template string, a ...any)
	inspectFuncErrorf   func(template string, a ...any)
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mLoggerMockErrorf

	funcInfo          func(a ...any)
	inspectFuncInfo   func(a ...any)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcInfof          func(template string, a ...any)
	inspectFuncInfof   func(template string, a ...any)
	afterInfofCounter  uint64
	beforeInfofCounter uint64
	InfofMock          mLoggerMockInfof

	funcPrintResponse          func(request *mm_contracts.Request, code int)
	inspectFuncPrintResponse   func(request *mm_contracts.Request, code int)
	afterPrintResponseCounter  uint64
	beforePrintResponseCounter uint64
	PrintResponseMock          mLoggerMockPrintResponse

	funcWarning          func(a ...any)
	inspectFuncWarning   func(a ...any)
	afterWarningCounter  uint64
	beforeWarningCounter uint64
	WarningMock          mLoggerMockWarning

	funcWarningf          func(template string, a ...any)
	inspectFuncWarningf   func(template string, a ...any)
	afterWarningfCounter  uint64
	beforeWarningfCounter uint64
	WarningfMock          mLoggerMockWarningf
}

// NewLoggerMock returns a mock for contracts.Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.DebugfMock = mLoggerMockDebugf{mock: m}
	m.DebugfMock.callArgs = []*LoggerMockDebugfParams{}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.ErrorfMock = mLoggerMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*LoggerMockErrorfParams{}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.InfofMock = mLoggerMockInfof{mock: m}
	m.InfofMock.callArgs = []*LoggerMockInfofParams{}

	m.PrintResponseMock = mLoggerMockPrintResponse{mock: m}
	m.PrintResponseMock.callArgs = []*LoggerMockPrintResponseParams{}

	m.WarningMock = mLoggerMockWarning{mock: m}
	m.WarningMock.callArgs = []*LoggerMockWarningParams{}

	m.WarningfMock = mLoggerMockWarningf{mock: m}
	m.WarningfMock.callArgs = []*LoggerMockWarningfParams{}

	return m
}

type mLoggerMockDebug struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock   *LoggerMock
	params *LoggerMockDebugParams

	Counter uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	a []any
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(a ...any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{a}
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(a ...any)) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	return mmDebug.mock
}

//Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(a ...any)) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	return mmDebug.mock
}

// Debug implements contracts.Logger
func (mmDebug *LoggerMock) Debug(a ...any) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(a...)
	}

	mm_params := &LoggerMockDebugParams{a}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_got := LoggerMockDebugParams{a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(a...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v", a)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debug")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Debug")
	}
}

type mLoggerMockDebugf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugfExpectation
	expectations       []*LoggerMockDebugfExpectation

	callArgs []*LoggerMockDebugfParams
	mutex    sync.RWMutex
}

// LoggerMockDebugfExpectation specifies expectation struct of the Logger.Debugf
type LoggerMockDebugfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockDebugfParams

	Counter uint64
}

// LoggerMockDebugfParams contains parameters of the Logger.Debugf
type LoggerMockDebugfParams struct {
	template string
	a        []any
}

// Expect sets up expected params for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Expect(template string, a ...any) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	mmDebugf.defaultExpectation.params = &LoggerMockDebugfParams{template, a}
	for _, e := range mmDebugf.expectations {
		if minimock.Equal(e.params, mmDebugf.defaultExpectation.params) {
			mmDebugf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugf.defaultExpectation.params)
		}
	}

	return mmDebugf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Inspect(f func(template string, a ...any)) *mLoggerMockDebugf {
	if mmDebugf.mock.inspectFuncDebugf != nil {
		mmDebugf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debugf")
	}

	mmDebugf.mock.inspectFuncDebugf = f

	return mmDebugf
}

// Return sets up results that will be returned by Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Return() *LoggerMock {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{mock: mmDebugf.mock}
	}

	return mmDebugf.mock
}

//Set uses given function f to mock the Logger.Debugf method
func (mmDebugf *mLoggerMockDebugf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmDebugf.defaultExpectation != nil {
		mmDebugf.mock.t.Fatalf("Default expectation is already set for the Logger.Debugf method")
	}

	if len(mmDebugf.expectations) > 0 {
		mmDebugf.mock.t.Fatalf("Some expectations are already set for the Logger.Debugf method")
	}

	mmDebugf.mock.funcDebugf = f
	return mmDebugf.mock
}

// Debugf implements contracts.Logger
func (mmDebugf *LoggerMock) Debugf(template string, a ...any) {
	mm_atomic.AddUint64(&mmDebugf.beforeDebugfCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugf.afterDebugfCounter, 1)

	if mmDebugf.inspectFuncDebugf != nil {
		mmDebugf.inspectFuncDebugf(template, a...)
	}

	mm_params := &LoggerMockDebugfParams{template, a}

	// Record call args
	mmDebugf.DebugfMock.mutex.Lock()
	mmDebugf.DebugfMock.callArgs = append(mmDebugf.DebugfMock.callArgs, mm_params)
	mmDebugf.DebugfMock.mutex.Unlock()

	for _, e := range mmDebugf.DebugfMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugf.DebugfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugf.DebugfMock.defaultExpectation.Counter, 1)
		mm_want := mmDebugf.DebugfMock.defaultExpectation.params
		mm_got := LoggerMockDebugfParams{template, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebugf.funcDebugf != nil {
		mmDebugf.funcDebugf(template, a...)
		return
	}
	mmDebugf.t.Fatalf("Unexpected call to LoggerMock.Debugf. %v %v", template, a)

}

// DebugfAfterCounter returns a count of finished LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.afterDebugfCounter)
}

// DebugfBeforeCounter returns a count of LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.beforeDebugfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debugf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugf *mLoggerMockDebugf) Calls() []*LoggerMockDebugfParams {
	mmDebugf.mutex.RLock()

	argCopy := make([]*LoggerMockDebugfParams, len(mmDebugf.callArgs))
	copy(argCopy, mmDebugf.callArgs)

	mmDebugf.mutex.RUnlock()

	return argCopy
}

// MinimockDebugfDone returns true if the count of the Debugf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugfDone() bool {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugfInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugfInspect() {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		if m.DebugfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debugf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *m.DebugfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Debugf")
	}
}

type mLoggerMockError struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock   *LoggerMock
	params *LoggerMockErrorParams

	Counter uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	a []any
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(a ...any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{a}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(a ...any)) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

//Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(a ...any)) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Error implements contracts.Logger
func (mmError *LoggerMock) Error(a ...any) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(a...)
	}

	mm_params := &LoggerMockErrorParams{a}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_got := LoggerMockErrorParams{a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(a...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v", a)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Error")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Error")
	}
}

type mLoggerMockErrorf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorfExpectation
	expectations       []*LoggerMockErrorfExpectation

	callArgs []*LoggerMockErrorfParams
	mutex    sync.RWMutex
}

// LoggerMockErrorfExpectation specifies expectation struct of the Logger.Errorf
type LoggerMockErrorfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockErrorfParams

	Counter uint64
}

// LoggerMockErrorfParams contains parameters of the Logger.Errorf
type LoggerMockErrorfParams struct {
	template string
	a        []any
}

// Expect sets up expected params for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Expect(template string, a ...any) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	mmErrorf.defaultExpectation.params = &LoggerMockErrorfParams{template, a}
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Inspect(f func(template string, a ...any)) *mLoggerMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Return() *LoggerMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{mock: mmErrorf.mock}
	}

	return mmErrorf.mock
}

//Set uses given function f to mock the Logger.Errorf method
func (mmErrorf *mLoggerMockErrorf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the Logger.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the Logger.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	return mmErrorf.mock
}

// Errorf implements contracts.Logger
func (mmErrorf *LoggerMock) Errorf(template string, a ...any) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(template, a...)
	}

	mm_params := &LoggerMockErrorfParams{template, a}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, mm_params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorf.ErrorfMock.defaultExpectation.params
		mm_got := LoggerMockErrorfParams{template, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(template, a...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to LoggerMock.Errorf. %v %v", template, a)

}

// ErrorfAfterCounter returns a count of finished LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mLoggerMockErrorf) Calls() []*LoggerMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*LoggerMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorfDone() bool {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorfInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Errorf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Errorf")
	}
}

type mLoggerMockInfo struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock   *LoggerMock
	params *LoggerMockInfoParams

	Counter uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	a []any
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(a ...any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{a}
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(a ...any)) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	return mmInfo.mock
}

//Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(a ...any)) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	return mmInfo.mock
}

// Info implements contracts.Logger
func (mmInfo *LoggerMock) Info(a ...any) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(a...)
	}

	mm_params := &LoggerMockInfoParams{a}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_got := LoggerMockInfoParams{a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(a...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v", a)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Info")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Info")
	}
}

type mLoggerMockInfof struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfofExpectation
	expectations       []*LoggerMockInfofExpectation

	callArgs []*LoggerMockInfofParams
	mutex    sync.RWMutex
}

// LoggerMockInfofExpectation specifies expectation struct of the Logger.Infof
type LoggerMockInfofExpectation struct {
	mock   *LoggerMock
	params *LoggerMockInfofParams

	Counter uint64
}

// LoggerMockInfofParams contains parameters of the Logger.Infof
type LoggerMockInfofParams struct {
	template string
	a        []any
}

// Expect sets up expected params for Logger.Infof
func (mmInfof *mLoggerMockInfof) Expect(template string, a ...any) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	mmInfof.defaultExpectation.params = &LoggerMockInfofParams{template, a}
	for _, e := range mmInfof.expectations {
		if minimock.Equal(e.params, mmInfof.defaultExpectation.params) {
			mmInfof.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfof.defaultExpectation.params)
		}
	}

	return mmInfof
}

// Inspect accepts an inspector function that has same arguments as the Logger.Infof
func (mmInfof *mLoggerMockInfof) Inspect(f func(template string, a ...any)) *mLoggerMockInfof {
	if mmInfof.mock.inspectFuncInfof != nil {
		mmInfof.mock.t.Fatalf("Inspect function is already set for LoggerMock.Infof")
	}

	mmInfof.mock.inspectFuncInfof = f

	return mmInfof
}

// Return sets up results that will be returned by Logger.Infof
func (mmInfof *mLoggerMockInfof) Return() *LoggerMock {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{mock: mmInfof.mock}
	}

	return mmInfof.mock
}

//Set uses given function f to mock the Logger.Infof method
func (mmInfof *mLoggerMockInfof) Set(f func(template string, a ...any)) *LoggerMock {
	if mmInfof.defaultExpectation != nil {
		mmInfof.mock.t.Fatalf("Default expectation is already set for the Logger.Infof method")
	}

	if len(mmInfof.expectations) > 0 {
		mmInfof.mock.t.Fatalf("Some expectations are already set for the Logger.Infof method")
	}

	mmInfof.mock.funcInfof = f
	return mmInfof.mock
}

// Infof implements contracts.Logger
func (mmInfof *LoggerMock) Infof(template string, a ...any) {
	mm_atomic.AddUint64(&mmInfof.beforeInfofCounter, 1)
	defer mm_atomic.AddUint64(&mmInfof.afterInfofCounter, 1)

	if mmInfof.inspectFuncInfof != nil {
		mmInfof.inspectFuncInfof(template, a...)
	}

	mm_params := &LoggerMockInfofParams{template, a}

	// Record call args
	mmInfof.InfofMock.mutex.Lock()
	mmInfof.InfofMock.callArgs = append(mmInfof.InfofMock.callArgs, mm_params)
	mmInfof.InfofMock.mutex.Unlock()

	for _, e := range mmInfof.InfofMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfof.InfofMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfof.InfofMock.defaultExpectation.Counter, 1)
		mm_want := mmInfof.InfofMock.defaultExpectation.params
		mm_got := LoggerMockInfofParams{template, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfof.funcInfof != nil {
		mmInfof.funcInfof(template, a...)
		return
	}
	mmInfof.t.Fatalf("Unexpected call to LoggerMock.Infof. %v %v", template, a)

}

// InfofAfterCounter returns a count of finished LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.afterInfofCounter)
}

// InfofBeforeCounter returns a count of LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.beforeInfofCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Infof.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfof *mLoggerMockInfof) Calls() []*LoggerMockInfofParams {
	mmInfof.mutex.RLock()

	argCopy := make([]*LoggerMockInfofParams, len(mmInfof.callArgs))
	copy(argCopy, mmInfof.callArgs)

	mmInfof.mutex.RUnlock()

	return argCopy
}

// MinimockInfofDone returns true if the count of the Infof invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfofDone() bool {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfofInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfofInspect() {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		if m.InfofMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Infof")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *m.InfofMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Infof")
	}
}

type mLoggerMockPrintResponse struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockPrintResponseExpectation
	expectations       []*LoggerMockPrintResponseExpectation

	callArgs []*LoggerMockPrintResponseParams
	mutex    sync.RWMutex
}

// LoggerMockPrintResponseExpectation specifies expectation struct of the Logger.PrintResponse
type LoggerMockPrintResponseExpectation struct {
	mock   *LoggerMock
	params *LoggerMockPrintResponseParams

	Counter uint64
}

// LoggerMockPrintResponseParams contains parameters of the Logger.PrintResponse
type LoggerMockPrintResponseParams struct {
	request *mm_contracts.Request
	code    int
}

// Expect sets up expected params for Logger.PrintResponse
func (mmPrintResponse *mLoggerMockPrintResponse) Expect(request *mm_contracts.Request, code int) *mLoggerMockPrintResponse {
	if mmPrintResponse.mock.funcPrintResponse != nil {
		mmPrintResponse.mock.t.Fatalf("LoggerMock.PrintResponse mock is already set by Set")
	}

	if mmPrintResponse.defaultExpectation == nil {
		mmPrintResponse.defaultExpectation = &LoggerMockPrintResponseExpectation{}
	}

	mmPrintResponse.defaultExpectation.params = &LoggerMockPrintResponseParams{request, code}
	for _, e := range mmPrintResponse.expectations {
		if minimock.Equal(e.params, mmPrintResponse.defaultExpectation.params) {
			mmPrintResponse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintResponse.defaultExpectation.params)
		}
	}

	return mmPrintResponse
}

// Inspect accepts an inspector function that has same arguments as the Logger.PrintResponse
func (mmPrintResponse *mLoggerMockPrintResponse) Inspect(f func(request *mm_contracts.Request, code int)) *mLoggerMockPrintResponse {
	if mmPrintResponse.mock.inspectFuncPrintResponse != nil {
		mmPrintResponse.mock.t.Fatalf("Inspect function is already set for LoggerMock.PrintResponse")
	}

	mmPrintResponse.mock.inspectFuncPrintResponse = f

	return mmPrintResponse
}

// Return sets up results that will be returned by Logger.PrintResponse
func (mmPrintResponse *mLoggerMockPrintResponse) Return() *LoggerMock {
	if mmPrintResponse.mock.funcPrintResponse != nil {
		mmPrintResponse.mock.t.Fatalf("LoggerMock.PrintResponse mock is already set by Set")
	}

	if mmPrintResponse.defaultExpectation == nil {
		mmPrintResponse.defaultExpectation = &LoggerMockPrintResponseExpectation{mock: mmPrintResponse.mock}
	}

	return mmPrintResponse.mock
}

//Set uses given function f to mock the Logger.PrintResponse method
func (mmPrintResponse *mLoggerMockPrintResponse) Set(f func(request *mm_contracts.Request, code int)) *LoggerMock {
	if mmPrintResponse.defaultExpectation != nil {
		mmPrintResponse.mock.t.Fatalf("Default expectation is already set for the Logger.PrintResponse method")
	}

	if len(mmPrintResponse.expectations) > 0 {
		mmPrintResponse.mock.t.Fatalf("Some expectations are already set for the Logger.PrintResponse method")
	}

	mmPrintResponse.mock.funcPrintResponse = f
	return mmPrintResponse.mock
}

// PrintResponse implements contracts.Logger
func (mmPrintResponse *LoggerMock) PrintResponse(request *mm_contracts.Request, code int) {
	mm_atomic.AddUint64(&mmPrintResponse.beforePrintResponseCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintResponse.afterPrintResponseCounter, 1)

	if mmPrintResponse.inspectFuncPrintResponse != nil {
		mmPrintResponse.inspectFuncPrintResponse(request, code)
	}

	mm_params := &LoggerMockPrintResponseParams{request, code}

	// Record call args
	mmPrintResponse.PrintResponseMock.mutex.Lock()
	mmPrintResponse.PrintResponseMock.callArgs = append(mmPrintResponse.PrintResponseMock.callArgs, mm_params)
	mmPrintResponse.PrintResponseMock.mutex.Unlock()

	for _, e := range mmPrintResponse.PrintResponseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrintResponse.PrintResponseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintResponse.PrintResponseMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintResponse.PrintResponseMock.defaultExpectation.params
		mm_got := LoggerMockPrintResponseParams{request, code}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintResponse.t.Errorf("LoggerMock.PrintResponse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrintResponse.funcPrintResponse != nil {
		mmPrintResponse.funcPrintResponse(request, code)
		return
	}
	mmPrintResponse.t.Fatalf("Unexpected call to LoggerMock.PrintResponse. %v %v", request, code)

}

// PrintResponseAfterCounter returns a count of finished LoggerMock.PrintResponse invocations
func (mmPrintResponse *LoggerMock) PrintResponseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintResponse.afterPrintResponseCounter)
}

// PrintResponseBeforeCounter returns a count of LoggerMock.PrintResponse invocations
func (mmPrintResponse *LoggerMock) PrintResponseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintResponse.beforePrintResponseCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.PrintResponse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintResponse *mLoggerMockPrintResponse) Calls() []*LoggerMockPrintResponseParams {
	mmPrintResponse.mutex.RLock()

	argCopy := make([]*LoggerMockPrintResponseParams, len(mmPrintResponse.callArgs))
	copy(argCopy, mmPrintResponse.callArgs)

	mmPrintResponse.mutex.RUnlock()

	return argCopy
}

// MinimockPrintResponseDone returns true if the count of the PrintResponse invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPrintResponseDone() bool {
	for _, e := range m.PrintResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintResponseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintResponse != nil && mm_atomic.LoadUint64(&m.afterPrintResponseCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrintResponseInspect logs each unmet expectation
func (m *LoggerMock) MinimockPrintResponseInspect() {
	for _, e := range m.PrintResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.PrintResponse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintResponseCounter) < 1 {
		if m.PrintResponseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.PrintResponse")
		} else {
			m.t.Errorf("Expected call to LoggerMock.PrintResponse with params: %#v", *m.PrintResponseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintResponse != nil && mm_atomic.LoadUint64(&m.afterPrintResponseCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.PrintResponse")
	}
}

type mLoggerMockWarning struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarningExpectation
	expectations       []*LoggerMockWarningExpectation

	callArgs []*LoggerMockWarningParams
	mutex    sync.RWMutex
}

// LoggerMockWarningExpectation specifies expectation struct of the Logger.Warning
type LoggerMockWarningExpectation struct {
	mock   *LoggerMock
	params *LoggerMockWarningParams

	Counter uint64
}

// LoggerMockWarningParams contains parameters of the Logger.Warning
type LoggerMockWarningParams struct {
	a []any
}

// Expect sets up expected params for Logger.Warning
func (mmWarning *mLoggerMockWarning) Expect(a ...any) *mLoggerMockWarning {
	if mmWarning.mock.funcWarning != nil {
		mmWarning.mock.t.Fatalf("LoggerMock.Warning mock is already set by Set")
	}

	if mmWarning.defaultExpectation == nil {
		mmWarning.defaultExpectation = &LoggerMockWarningExpectation{}
	}

	mmWarning.defaultExpectation.params = &LoggerMockWarningParams{a}
	for _, e := range mmWarning.expectations {
		if minimock.Equal(e.params, mmWarning.defaultExpectation.params) {
			mmWarning.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarning.defaultExpectation.params)
		}
	}

	return mmWarning
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warning
func (mmWarning *mLoggerMockWarning) Inspect(f func(a ...any)) *mLoggerMockWarning {
	if mmWarning.mock.inspectFuncWarning != nil {
		mmWarning.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warning")
	}

	mmWarning.mock.inspectFuncWarning = f

	return mmWarning
}

// Return sets up results that will be returned by Logger.Warning
func (mmWarning *mLoggerMockWarning) Return() *LoggerMock {
	if mmWarning.mock.funcWarning != nil {
		mmWarning.mock.t.Fatalf("LoggerMock.Warning mock is already set by Set")
	}

	if mmWarning.defaultExpectation == nil {
		mmWarning.defaultExpectation = &LoggerMockWarningExpectation{mock: mmWarning.mock}
	}

	return mmWarning.mock
}

//Set uses given function f to mock the Logger.Warning method
func (mmWarning *mLoggerMockWarning) Set(f func(a ...any)) *LoggerMock {
	if mmWarning.defaultExpectation != nil {
		mmWarning.mock.t.Fatalf("Default expectation is already set for the Logger.Warning method")
	}

	if len(mmWarning.expectations) > 0 {
		mmWarning.mock.t.Fatalf("Some expectations are already set for the Logger.Warning method")
	}

	mmWarning.mock.funcWarning = f
	return mmWarning.mock
}

// Warning implements contracts.Logger
func (mmWarning *LoggerMock) Warning(a ...any) {
	mm_atomic.AddUint64(&mmWarning.beforeWarningCounter, 1)
	defer mm_atomic.AddUint64(&mmWarning.afterWarningCounter, 1)

	if mmWarning.inspectFuncWarning != nil {
		mmWarning.inspectFuncWarning(a...)
	}

	mm_params := &LoggerMockWarningParams{a}

	// Record call args
	mmWarning.WarningMock.mutex.Lock()
	mmWarning.WarningMock.callArgs = append(mmWarning.WarningMock.callArgs, mm_params)
	mmWarning.WarningMock.mutex.Unlock()

	for _, e := range mmWarning.WarningMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarning.WarningMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarning.WarningMock.defaultExpectation.Counter, 1)
		mm_want := mmWarning.WarningMock.defaultExpectation.params
		mm_got := LoggerMockWarningParams{a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarning.t.Errorf("LoggerMock.Warning got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarning.funcWarning != nil {
		mmWarning.funcWarning(a...)
		return
	}
	mmWarning.t.Fatalf("Unexpected call to LoggerMock.Warning. %v", a)

}

// WarningAfterCounter returns a count of finished LoggerMock.Warning invocations
func (mmWarning *LoggerMock) WarningAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarning.afterWarningCounter)
}

// WarningBeforeCounter returns a count of LoggerMock.Warning invocations
func (mmWarning *LoggerMock) WarningBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarning.beforeWarningCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warning.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarning *mLoggerMockWarning) Calls() []*LoggerMockWarningParams {
	mmWarning.mutex.RLock()

	argCopy := make([]*LoggerMockWarningParams, len(mmWarning.callArgs))
	copy(argCopy, mmWarning.callArgs)

	mmWarning.mutex.RUnlock()

	return argCopy
}

// MinimockWarningDone returns true if the count of the Warning invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarningDone() bool {
	for _, e := range m.WarningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarningMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarningCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarning != nil && mm_atomic.LoadUint64(&m.afterWarningCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarningInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarningInspect() {
	for _, e := range m.WarningMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warning with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarningMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarningCounter) < 1 {
		if m.WarningMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warning")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warning with params: %#v", *m.WarningMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarning != nil && mm_atomic.LoadUint64(&m.afterWarningCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Warning")
	}
}

type mLoggerMockWarningf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarningfExpectation
	expectations       []*LoggerMockWarningfExpectation

	callArgs []*LoggerMockWarningfParams
	mutex    sync.RWMutex
}

// LoggerMockWarningfExpectation specifies expectation struct of the Logger.Warningf
type LoggerMockWarningfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockWarningfParams

	Counter uint64
}

// LoggerMockWarningfParams contains parameters of the Logger.Warningf
type LoggerMockWarningfParams struct {
	template string
	a        []any
}

// Expect sets up expected params for Logger.Warningf
func (mmWarningf *mLoggerMockWarningf) Expect(template string, a ...any) *mLoggerMockWarningf {
	if mmWarningf.mock.funcWarningf != nil {
		mmWarningf.mock.t.Fatalf("LoggerMock.Warningf mock is already set by Set")
	}

	if mmWarningf.defaultExpectation == nil {
		mmWarningf.defaultExpectation = &LoggerMockWarningfExpectation{}
	}

	mmWarningf.defaultExpectation.params = &LoggerMockWarningfParams{template, a}
	for _, e := range mmWarningf.expectations {
		if minimock.Equal(e.params, mmWarningf.defaultExpectation.params) {
			mmWarningf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarningf.defaultExpectation.params)
		}
	}

	return mmWarningf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warningf
func (mmWarningf *mLoggerMockWarningf) Inspect(f func(template string, a ...any)) *mLoggerMockWarningf {
	if mmWarningf.mock.inspectFuncWarningf != nil {
		mmWarningf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warningf")
	}

	mmWarningf.mock.inspectFuncWarningf = f

	return mmWarningf
}

// Return sets up results that will be returned by Logger.Warningf
func (mmWarningf *mLoggerMockWarningf) Return() *LoggerMock {
	if mmWarningf.mock.funcWarningf != nil {
		mmWarningf.mock.t.Fatalf("LoggerMock.Warningf mock is already set by Set")
	}

	if mmWarningf.defaultExpectation == nil {
		mmWarningf.defaultExpectation = &LoggerMockWarningfExpectation{mock: mmWarningf.mock}
	}

	return mmWarningf.mock
}

//Set uses given function f to mock the Logger.Warningf method
func (mmWarningf *mLoggerMockWarningf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmWarningf.defaultExpectation != nil {
		mmWarningf.mock.t.Fatalf("Default expectation is already set for the Logger.Warningf method")
	}

	if len(mmWarningf.expectations) > 0 {
		mmWarningf.mock.t.Fatalf("Some expectations are already set for the Logger.Warningf method")
	}

	mmWarningf.mock.funcWarningf = f
	return mmWarningf.mock
}

// Warningf implements contracts.Logger
func (mmWarningf *LoggerMock) Warningf(template string, a ...any) {
	mm_atomic.AddUint64(&mmWarningf.beforeWarningfCounter, 1)
	defer mm_atomic.AddUint64(&mmWarningf.afterWarningfCounter, 1)

	if mmWarningf.inspectFuncWarningf != nil {
		mmWarningf.inspectFuncWarningf(template, a...)
	}

	mm_params := &LoggerMockWarningfParams{template, a}

	// Record call args
	mmWarningf.WarningfMock.mutex.Lock()
	mmWarningf.WarningfMock.callArgs = append(mmWarningf.WarningfMock.callArgs, mm_params)
	mmWarningf.WarningfMock.mutex.Unlock()

	for _, e := range mmWarningf.WarningfMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarningf.WarningfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarningf.WarningfMock.defaultExpectation.Counter, 1)
		mm_want := mmWarningf.WarningfMock.defaultExpectation.params
		mm_got := LoggerMockWarningfParams{template, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarningf.t.Errorf("LoggerMock.Warningf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarningf.funcWarningf != nil {
		mmWarningf.funcWarningf(template, a...)
		return
	}
	mmWarningf.t.Fatalf("Unexpected call to LoggerMock.Warningf. %v %v", template, a)

}

// WarningfAfterCounter returns a count of finished LoggerMock.Warningf invocations
func (mmWarningf *LoggerMock) WarningfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarningf.afterWarningfCounter)
}

// WarningfBeforeCounter returns a count of LoggerMock.Warningf invocations
func (mmWarningf *LoggerMock) WarningfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarningf.beforeWarningfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warningf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarningf *mLoggerMockWarningf) Calls() []*LoggerMockWarningfParams {
	mmWarningf.mutex.RLock()

	argCopy := make([]*LoggerMockWarningfParams, len(mmWarningf.callArgs))
	copy(argCopy, mmWarningf.callArgs)

	mmWarningf.mutex.RUnlock()

	return argCopy
}

// MinimockWarningfDone returns true if the count of the Warningf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarningfDone() bool {
	for _, e := range m.WarningfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarningfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarningfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarningf != nil && mm_atomic.LoadUint64(&m.afterWarningfCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarningfInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarningfInspect() {
	for _, e := range m.WarningfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warningf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarningfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarningfCounter) < 1 {
		if m.WarningfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warningf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warningf with params: %#v", *m.WarningfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarningf != nil && mm_atomic.LoadUint64(&m.afterWarningfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Warningf")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDebugInspect()

		m.MinimockDebugfInspect()

		m.MinimockErrorInspect()

		m.MinimockErrorfInspect()

		m.MinimockInfoInspect()

		m.MinimockInfofInspect()

		m.MinimockPrintResponseInspect()

		m.MinimockWarningInspect()

		m.MinimockWarningfInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockDebugfDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockInfoDone() &&
		m.MinimockInfofDone() &&
		m.MinimockPrintResponseDone() &&
		m.MinimockWarningDone() &&
		m.MinimockWarningfDone()
}
