// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/evg4b/uncors/internal/contracts.Logger -o logger_mock.go -n LoggerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoggerMock implements mm_contracts.Logger
type LoggerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDebug          func(msg any, keyvals ...any)
	funcDebugOrigin    string
	inspectFuncDebug   func(msg any, keyvals ...any)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcDebugf          func(template string, a ...any)
	funcDebugfOrigin    string
	inspectFuncDebugf   func(template string, a ...any)
	afterDebugfCounter  uint64
	beforeDebugfCounter uint64
	DebugfMock          mLoggerMockDebugf

	funcError          func(msg any, keyvals ...any)
	funcErrorOrigin    string
	inspectFuncError   func(msg any, keyvals ...any)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcErrorf          func(template string, a ...any)
	funcErrorfOrigin    string
	inspectFuncErrorf   func(template string, a ...any)
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mLoggerMockErrorf

	funcInfo          func(msg any, keyvals ...any)
	funcInfoOrigin    string
	inspectFuncInfo   func(msg any, keyvals ...any)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcInfof          func(template string, a ...any)
	funcInfofOrigin    string
	inspectFuncInfof   func(template string, a ...any)
	afterInfofCounter  uint64
	beforeInfofCounter uint64
	InfofMock          mLoggerMockInfof

	funcPrint          func(msg any, keyvals ...any)
	funcPrintOrigin    string
	inspectFuncPrint   func(msg any, keyvals ...any)
	afterPrintCounter  uint64
	beforePrintCounter uint64
	PrintMock          mLoggerMockPrint

	funcPrintf          func(format string, args ...any)
	funcPrintfOrigin    string
	inspectFuncPrintf   func(format string, args ...any)
	afterPrintfCounter  uint64
	beforePrintfCounter uint64
	PrintfMock          mLoggerMockPrintf

	funcWarn          func(msg any, keyvals ...any)
	funcWarnOrigin    string
	inspectFuncWarn   func(msg any, keyvals ...any)
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerMockWarn

	funcWarnf          func(template string, a ...any)
	funcWarnfOrigin    string
	inspectFuncWarnf   func(template string, a ...any)
	afterWarnfCounter  uint64
	beforeWarnfCounter uint64
	WarnfMock          mLoggerMockWarnf
}

// NewLoggerMock returns a mock for mm_contracts.Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.DebugfMock = mLoggerMockDebugf{mock: m}
	m.DebugfMock.callArgs = []*LoggerMockDebugfParams{}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.ErrorfMock = mLoggerMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*LoggerMockErrorfParams{}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.InfofMock = mLoggerMockInfof{mock: m}
	m.InfofMock.callArgs = []*LoggerMockInfofParams{}

	m.PrintMock = mLoggerMockPrint{mock: m}
	m.PrintMock.callArgs = []*LoggerMockPrintParams{}

	m.PrintfMock = mLoggerMockPrintf{mock: m}
	m.PrintfMock.callArgs = []*LoggerMockPrintfParams{}

	m.WarnMock = mLoggerMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerMockWarnParams{}

	m.WarnfMock = mLoggerMockWarnf{mock: m}
	m.WarnfMock.callArgs = []*LoggerMockWarnfParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerMockDebug struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockDebugParams
	paramPtrs          *LoggerMockDebugParamPtrs
	expectationOrigins LoggerMockDebugExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	msg     any
	keyvals []any
}

// LoggerMockDebugParamPtrs contains pointers to parameters of the Logger.Debug
type LoggerMockDebugParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// LoggerMockDebugOrigins contains origins of expectations of the Logger.Debug
type LoggerMockDebugExpectationOrigins struct {
	origin        string
	originMsg     string
	originKeyvals string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebug *mLoggerMockDebug) Optional() *mLoggerMockDebug {
	mmDebug.optional = true
	return mmDebug
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(msg any, keyvals ...any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.paramPtrs != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by ExpectParams functions")
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{msg, keyvals}
	mmDebug.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// ExpectMsgParam1 sets up expected param msg for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectMsgParam1(msg any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.msg = &msg
	mmDebug.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmDebug
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.keyvals = &keyvals
	mmDebug.defaultExpectation.expectationOrigins.originKeyvals = minimock.CallerInfo(1)

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	mmDebug.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	mmDebug.mock.funcDebugOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// When sets expectation for the Logger.Debug which will trigger the result defined by the following
// Then helper
func (mmDebug *mLoggerMockDebug) When(msg any, keyvals ...any) *LoggerMockDebugExpectation {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	expectation := &LoggerMockDebugExpectation{
		mock:               mmDebug.mock,
		params:             &LoggerMockDebugParams{msg, keyvals},
		expectationOrigins: LoggerMockDebugExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDebug.expectations = append(mmDebug.expectations, expectation)
	return expectation
}

// Then sets up Logger.Debug return parameters for the expectation previously defined by the When method

func (e *LoggerMockDebugExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Debug should be invoked
func (mmDebug *mLoggerMockDebug) Times(n uint64) *mLoggerMockDebug {
	if n == 0 {
		mmDebug.mock.t.Fatalf("Times of LoggerMock.Debug mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebug.expectedInvocations, n)
	mmDebug.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebug
}

func (mmDebug *mLoggerMockDebug) invocationsDone() bool {
	if len(mmDebug.expectations) == 0 && mmDebug.defaultExpectation == nil && mmDebug.mock.funcDebug == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebug.mock.afterDebugCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebug.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debug implements mm_contracts.Logger
func (mmDebug *LoggerMock) Debug(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	mmDebug.t.Helper()

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(msg, keyvals...)
	}

	mm_params := LoggerMockDebugParams{msg, keyvals}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, &mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_want_ptrs := mmDebug.DebugMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter keyvals, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originKeyvals, *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebug.DebugMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(msg, keyvals...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v %v", msg, keyvals)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	if m.DebugMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugMock.invocationsDone()
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebugCounter := mm_atomic.LoadUint64(&m.afterDebugCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && afterDebugCounter < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s", m.DebugMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s with params: %#v", m.DebugMock.defaultExpectation.expectationOrigins.origin, *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && afterDebugCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Debug at\n%s", m.funcDebugOrigin)
	}

	if !m.DebugMock.invocationsDone() && afterDebugCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debug at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebugMock.expectedInvocations), m.DebugMock.expectedInvocationsOrigin, afterDebugCounter)
	}
}

type mLoggerMockDebugf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugfExpectation
	expectations       []*LoggerMockDebugfExpectation

	callArgs []*LoggerMockDebugfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockDebugfExpectation specifies expectation struct of the Logger.Debugf
type LoggerMockDebugfExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockDebugfParams
	paramPtrs          *LoggerMockDebugfParamPtrs
	expectationOrigins LoggerMockDebugfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockDebugfParams contains parameters of the Logger.Debugf
type LoggerMockDebugfParams struct {
	template string
	a        []any
}

// LoggerMockDebugfParamPtrs contains pointers to parameters of the Logger.Debugf
type LoggerMockDebugfParamPtrs struct {
	template *string
	a        *[]any
}

// LoggerMockDebugfOrigins contains origins of expectations of the Logger.Debugf
type LoggerMockDebugfExpectationOrigins struct {
	origin         string
	originTemplate string
	originA        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebugf *mLoggerMockDebugf) Optional() *mLoggerMockDebugf {
	mmDebugf.optional = true
	return mmDebugf
}

// Expect sets up expected params for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Expect(template string, a ...any) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.paramPtrs != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by ExpectParams functions")
	}

	mmDebugf.defaultExpectation.params = &LoggerMockDebugfParams{template, a}
	mmDebugf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebugf.expectations {
		if minimock.Equal(e.params, mmDebugf.defaultExpectation.params) {
			mmDebugf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugf.defaultExpectation.params)
		}
	}

	return mmDebugf
}

// ExpectTemplateParam1 sets up expected param template for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) ExpectTemplateParam1(template string) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.template = &template
	mmDebugf.defaultExpectation.expectationOrigins.originTemplate = minimock.CallerInfo(1)

	return mmDebugf
}

// ExpectAParam2 sets up expected param a for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) ExpectAParam2(a ...any) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.a = &a
	mmDebugf.defaultExpectation.expectationOrigins.originA = minimock.CallerInfo(1)

	return mmDebugf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Inspect(f func(template string, a ...any)) *mLoggerMockDebugf {
	if mmDebugf.mock.inspectFuncDebugf != nil {
		mmDebugf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debugf")
	}

	mmDebugf.mock.inspectFuncDebugf = f

	return mmDebugf
}

// Return sets up results that will be returned by Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Return() *LoggerMock {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{mock: mmDebugf.mock}
	}

	mmDebugf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebugf.mock
}

// Set uses given function f to mock the Logger.Debugf method
func (mmDebugf *mLoggerMockDebugf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmDebugf.defaultExpectation != nil {
		mmDebugf.mock.t.Fatalf("Default expectation is already set for the Logger.Debugf method")
	}

	if len(mmDebugf.expectations) > 0 {
		mmDebugf.mock.t.Fatalf("Some expectations are already set for the Logger.Debugf method")
	}

	mmDebugf.mock.funcDebugf = f
	mmDebugf.mock.funcDebugfOrigin = minimock.CallerInfo(1)
	return mmDebugf.mock
}

// When sets expectation for the Logger.Debugf which will trigger the result defined by the following
// Then helper
func (mmDebugf *mLoggerMockDebugf) When(template string, a ...any) *LoggerMockDebugfExpectation {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	expectation := &LoggerMockDebugfExpectation{
		mock:               mmDebugf.mock,
		params:             &LoggerMockDebugfParams{template, a},
		expectationOrigins: LoggerMockDebugfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDebugf.expectations = append(mmDebugf.expectations, expectation)
	return expectation
}

// Then sets up Logger.Debugf return parameters for the expectation previously defined by the When method

func (e *LoggerMockDebugfExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Debugf should be invoked
func (mmDebugf *mLoggerMockDebugf) Times(n uint64) *mLoggerMockDebugf {
	if n == 0 {
		mmDebugf.mock.t.Fatalf("Times of LoggerMock.Debugf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebugf.expectedInvocations, n)
	mmDebugf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebugf
}

func (mmDebugf *mLoggerMockDebugf) invocationsDone() bool {
	if len(mmDebugf.expectations) == 0 && mmDebugf.defaultExpectation == nil && mmDebugf.mock.funcDebugf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebugf.mock.afterDebugfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebugf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debugf implements mm_contracts.Logger
func (mmDebugf *LoggerMock) Debugf(template string, a ...any) {
	mm_atomic.AddUint64(&mmDebugf.beforeDebugfCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugf.afterDebugfCounter, 1)

	mmDebugf.t.Helper()

	if mmDebugf.inspectFuncDebugf != nil {
		mmDebugf.inspectFuncDebugf(template, a...)
	}

	mm_params := LoggerMockDebugfParams{template, a}

	// Record call args
	mmDebugf.DebugfMock.mutex.Lock()
	mmDebugf.DebugfMock.callArgs = append(mmDebugf.DebugfMock.callArgs, &mm_params)
	mmDebugf.DebugfMock.mutex.Unlock()

	for _, e := range mmDebugf.DebugfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugf.DebugfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugf.DebugfMock.defaultExpectation.Counter, 1)
		mm_want := mmDebugf.DebugfMock.defaultExpectation.params
		mm_want_ptrs := mmDebugf.DebugfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugfParams{template, a}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.template != nil && !minimock.Equal(*mm_want_ptrs.template, mm_got.template) {
				mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameter template, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebugf.DebugfMock.defaultExpectation.expectationOrigins.originTemplate, *mm_want_ptrs.template, mm_got.template, minimock.Diff(*mm_want_ptrs.template, mm_got.template))
			}

			if mm_want_ptrs.a != nil && !minimock.Equal(*mm_want_ptrs.a, mm_got.a) {
				mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameter a, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebugf.DebugfMock.defaultExpectation.expectationOrigins.originA, *mm_want_ptrs.a, mm_got.a, minimock.Diff(*mm_want_ptrs.a, mm_got.a))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebugf.DebugfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebugf.funcDebugf != nil {
		mmDebugf.funcDebugf(template, a...)
		return
	}
	mmDebugf.t.Fatalf("Unexpected call to LoggerMock.Debugf. %v %v", template, a)

}

// DebugfAfterCounter returns a count of finished LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.afterDebugfCounter)
}

// DebugfBeforeCounter returns a count of LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.beforeDebugfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debugf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugf *mLoggerMockDebugf) Calls() []*LoggerMockDebugfParams {
	mmDebugf.mutex.RLock()

	argCopy := make([]*LoggerMockDebugfParams, len(mmDebugf.callArgs))
	copy(argCopy, mmDebugf.callArgs)

	mmDebugf.mutex.RUnlock()

	return argCopy
}

// MinimockDebugfDone returns true if the count of the Debugf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugfDone() bool {
	if m.DebugfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugfMock.invocationsDone()
}

// MinimockDebugfInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugfInspect() {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debugf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebugfCounter := mm_atomic.LoadUint64(&m.afterDebugfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && afterDebugfCounter < 1 {
		if m.DebugfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Debugf at\n%s", m.DebugfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debugf at\n%s with params: %#v", m.DebugfMock.defaultExpectation.expectationOrigins.origin, *m.DebugfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && afterDebugfCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Debugf at\n%s", m.funcDebugfOrigin)
	}

	if !m.DebugfMock.invocationsDone() && afterDebugfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debugf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebugfMock.expectedInvocations), m.DebugfMock.expectedInvocationsOrigin, afterDebugfCounter)
	}
}

type mLoggerMockError struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockErrorParams
	paramPtrs          *LoggerMockErrorParamPtrs
	expectationOrigins LoggerMockErrorExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	msg     any
	keyvals []any
}

// LoggerMockErrorParamPtrs contains pointers to parameters of the Logger.Error
type LoggerMockErrorParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// LoggerMockErrorOrigins contains origins of expectations of the Logger.Error
type LoggerMockErrorExpectationOrigins struct {
	origin        string
	originMsg     string
	originKeyvals string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmError *mLoggerMockError) Optional() *mLoggerMockError {
	mmError.optional = true
	return mmError
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(msg any, keyvals ...any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.paramPtrs != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by ExpectParams functions")
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{msg, keyvals}
	mmError.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// ExpectMsgParam1 sets up expected param msg for Logger.Error
func (mmError *mLoggerMockError) ExpectMsgParam1(msg any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.msg = &msg
	mmError.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmError
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Error
func (mmError *mLoggerMockError) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.keyvals = &keyvals
	mmError.defaultExpectation.expectationOrigins.originKeyvals = minimock.CallerInfo(1)

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	mmError.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	mmError.mock.funcErrorOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// When sets expectation for the Logger.Error which will trigger the result defined by the following
// Then helper
func (mmError *mLoggerMockError) When(msg any, keyvals ...any) *LoggerMockErrorExpectation {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	expectation := &LoggerMockErrorExpectation{
		mock:               mmError.mock,
		params:             &LoggerMockErrorParams{msg, keyvals},
		expectationOrigins: LoggerMockErrorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmError.expectations = append(mmError.expectations, expectation)
	return expectation
}

// Then sets up Logger.Error return parameters for the expectation previously defined by the When method

func (e *LoggerMockErrorExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Error should be invoked
func (mmError *mLoggerMockError) Times(n uint64) *mLoggerMockError {
	if n == 0 {
		mmError.mock.t.Fatalf("Times of LoggerMock.Error mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmError.expectedInvocations, n)
	mmError.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmError
}

func (mmError *mLoggerMockError) invocationsDone() bool {
	if len(mmError.expectations) == 0 && mmError.defaultExpectation == nil && mmError.mock.funcError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmError.mock.afterErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Error implements mm_contracts.Logger
func (mmError *LoggerMock) Error(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	mmError.t.Helper()

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(msg, keyvals...)
	}

	mm_params := LoggerMockErrorParams{msg, keyvals}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, &mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_want_ptrs := mmError.ErrorMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter keyvals, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originKeyvals, *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmError.ErrorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(msg, keyvals...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v %v", msg, keyvals)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	if m.ErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorMock.invocationsDone()
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterErrorCounter := mm_atomic.LoadUint64(&m.afterErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && afterErrorCounter < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s", m.ErrorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s with params: %#v", m.ErrorMock.defaultExpectation.expectationOrigins.origin, *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && afterErrorCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Error at\n%s", m.funcErrorOrigin)
	}

	if !m.ErrorMock.invocationsDone() && afterErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Error at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorMock.expectedInvocations), m.ErrorMock.expectedInvocationsOrigin, afterErrorCounter)
	}
}

type mLoggerMockErrorf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorfExpectation
	expectations       []*LoggerMockErrorfExpectation

	callArgs []*LoggerMockErrorfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockErrorfExpectation specifies expectation struct of the Logger.Errorf
type LoggerMockErrorfExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockErrorfParams
	paramPtrs          *LoggerMockErrorfParamPtrs
	expectationOrigins LoggerMockErrorfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockErrorfParams contains parameters of the Logger.Errorf
type LoggerMockErrorfParams struct {
	template string
	a        []any
}

// LoggerMockErrorfParamPtrs contains pointers to parameters of the Logger.Errorf
type LoggerMockErrorfParamPtrs struct {
	template *string
	a        *[]any
}

// LoggerMockErrorfOrigins contains origins of expectations of the Logger.Errorf
type LoggerMockErrorfExpectationOrigins struct {
	origin         string
	originTemplate string
	originA        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmErrorf *mLoggerMockErrorf) Optional() *mLoggerMockErrorf {
	mmErrorf.optional = true
	return mmErrorf
}

// Expect sets up expected params for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Expect(template string, a ...any) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.paramPtrs != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by ExpectParams functions")
	}

	mmErrorf.defaultExpectation.params = &LoggerMockErrorfParams{template, a}
	mmErrorf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// ExpectTemplateParam1 sets up expected param template for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) ExpectTemplateParam1(template string) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.template = &template
	mmErrorf.defaultExpectation.expectationOrigins.originTemplate = minimock.CallerInfo(1)

	return mmErrorf
}

// ExpectAParam2 sets up expected param a for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) ExpectAParam2(a ...any) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.a = &a
	mmErrorf.defaultExpectation.expectationOrigins.originA = minimock.CallerInfo(1)

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Inspect(f func(template string, a ...any)) *mLoggerMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Return() *LoggerMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{mock: mmErrorf.mock}
	}

	mmErrorf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmErrorf.mock
}

// Set uses given function f to mock the Logger.Errorf method
func (mmErrorf *mLoggerMockErrorf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the Logger.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the Logger.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	mmErrorf.mock.funcErrorfOrigin = minimock.CallerInfo(1)
	return mmErrorf.mock
}

// When sets expectation for the Logger.Errorf which will trigger the result defined by the following
// Then helper
func (mmErrorf *mLoggerMockErrorf) When(template string, a ...any) *LoggerMockErrorfExpectation {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	expectation := &LoggerMockErrorfExpectation{
		mock:               mmErrorf.mock,
		params:             &LoggerMockErrorfParams{template, a},
		expectationOrigins: LoggerMockErrorfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmErrorf.expectations = append(mmErrorf.expectations, expectation)
	return expectation
}

// Then sets up Logger.Errorf return parameters for the expectation previously defined by the When method

func (e *LoggerMockErrorfExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Errorf should be invoked
func (mmErrorf *mLoggerMockErrorf) Times(n uint64) *mLoggerMockErrorf {
	if n == 0 {
		mmErrorf.mock.t.Fatalf("Times of LoggerMock.Errorf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmErrorf.expectedInvocations, n)
	mmErrorf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmErrorf
}

func (mmErrorf *mLoggerMockErrorf) invocationsDone() bool {
	if len(mmErrorf.expectations) == 0 && mmErrorf.defaultExpectation == nil && mmErrorf.mock.funcErrorf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmErrorf.mock.afterErrorfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmErrorf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Errorf implements mm_contracts.Logger
func (mmErrorf *LoggerMock) Errorf(template string, a ...any) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	mmErrorf.t.Helper()

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(template, a...)
	}

	mm_params := LoggerMockErrorfParams{template, a}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, &mm_params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorf.ErrorfMock.defaultExpectation.params
		mm_want_ptrs := mmErrorf.ErrorfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorfParams{template, a}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.template != nil && !minimock.Equal(*mm_want_ptrs.template, mm_got.template) {
				mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameter template, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmErrorf.ErrorfMock.defaultExpectation.expectationOrigins.originTemplate, *mm_want_ptrs.template, mm_got.template, minimock.Diff(*mm_want_ptrs.template, mm_got.template))
			}

			if mm_want_ptrs.a != nil && !minimock.Equal(*mm_want_ptrs.a, mm_got.a) {
				mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameter a, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmErrorf.ErrorfMock.defaultExpectation.expectationOrigins.originA, *mm_want_ptrs.a, mm_got.a, minimock.Diff(*mm_want_ptrs.a, mm_got.a))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmErrorf.ErrorfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(template, a...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to LoggerMock.Errorf. %v %v", template, a)

}

// ErrorfAfterCounter returns a count of finished LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mLoggerMockErrorf) Calls() []*LoggerMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*LoggerMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorfDone() bool {
	if m.ErrorfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorfMock.invocationsDone()
}

// MinimockErrorfInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Errorf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterErrorfCounter := mm_atomic.LoadUint64(&m.afterErrorfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && afterErrorfCounter < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Errorf at\n%s", m.ErrorfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Errorf at\n%s with params: %#v", m.ErrorfMock.defaultExpectation.expectationOrigins.origin, *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && afterErrorfCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Errorf at\n%s", m.funcErrorfOrigin)
	}

	if !m.ErrorfMock.invocationsDone() && afterErrorfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Errorf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorfMock.expectedInvocations), m.ErrorfMock.expectedInvocationsOrigin, afterErrorfCounter)
	}
}

type mLoggerMockInfo struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockInfoParams
	paramPtrs          *LoggerMockInfoParamPtrs
	expectationOrigins LoggerMockInfoExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	msg     any
	keyvals []any
}

// LoggerMockInfoParamPtrs contains pointers to parameters of the Logger.Info
type LoggerMockInfoParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// LoggerMockInfoOrigins contains origins of expectations of the Logger.Info
type LoggerMockInfoExpectationOrigins struct {
	origin        string
	originMsg     string
	originKeyvals string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfo *mLoggerMockInfo) Optional() *mLoggerMockInfo {
	mmInfo.optional = true
	return mmInfo
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(msg any, keyvals ...any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.paramPtrs != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by ExpectParams functions")
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{msg, keyvals}
	mmInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// ExpectMsgParam1 sets up expected param msg for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectMsgParam1(msg any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.msg = &msg
	mmInfo.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmInfo
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.keyvals = &keyvals
	mmInfo.defaultExpectation.expectationOrigins.originKeyvals = minimock.CallerInfo(1)

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	mmInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	mmInfo.mock.funcInfoOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// When sets expectation for the Logger.Info which will trigger the result defined by the following
// Then helper
func (mmInfo *mLoggerMockInfo) When(msg any, keyvals ...any) *LoggerMockInfoExpectation {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	expectation := &LoggerMockInfoExpectation{
		mock:               mmInfo.mock,
		params:             &LoggerMockInfoParams{msg, keyvals},
		expectationOrigins: LoggerMockInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInfo.expectations = append(mmInfo.expectations, expectation)
	return expectation
}

// Then sets up Logger.Info return parameters for the expectation previously defined by the When method

func (e *LoggerMockInfoExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Info should be invoked
func (mmInfo *mLoggerMockInfo) Times(n uint64) *mLoggerMockInfo {
	if n == 0 {
		mmInfo.mock.t.Fatalf("Times of LoggerMock.Info mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfo.expectedInvocations, n)
	mmInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInfo
}

func (mmInfo *mLoggerMockInfo) invocationsDone() bool {
	if len(mmInfo.expectations) == 0 && mmInfo.defaultExpectation == nil && mmInfo.mock.funcInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfo.mock.afterInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Info implements mm_contracts.Logger
func (mmInfo *LoggerMock) Info(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	mmInfo.t.Helper()

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(msg, keyvals...)
	}

	mm_params := LoggerMockInfoParams{msg, keyvals}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, &mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_want_ptrs := mmInfo.InfoMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfoParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter keyvals, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originKeyvals, *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInfo.InfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(msg, keyvals...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v %v", msg, keyvals)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	if m.InfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfoMock.invocationsDone()
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInfoCounter := mm_atomic.LoadUint64(&m.afterInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && afterInfoCounter < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s", m.InfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s with params: %#v", m.InfoMock.defaultExpectation.expectationOrigins.origin, *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && afterInfoCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Info at\n%s", m.funcInfoOrigin)
	}

	if !m.InfoMock.invocationsDone() && afterInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Info at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InfoMock.expectedInvocations), m.InfoMock.expectedInvocationsOrigin, afterInfoCounter)
	}
}

type mLoggerMockInfof struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfofExpectation
	expectations       []*LoggerMockInfofExpectation

	callArgs []*LoggerMockInfofParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockInfofExpectation specifies expectation struct of the Logger.Infof
type LoggerMockInfofExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockInfofParams
	paramPtrs          *LoggerMockInfofParamPtrs
	expectationOrigins LoggerMockInfofExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockInfofParams contains parameters of the Logger.Infof
type LoggerMockInfofParams struct {
	template string
	a        []any
}

// LoggerMockInfofParamPtrs contains pointers to parameters of the Logger.Infof
type LoggerMockInfofParamPtrs struct {
	template *string
	a        *[]any
}

// LoggerMockInfofOrigins contains origins of expectations of the Logger.Infof
type LoggerMockInfofExpectationOrigins struct {
	origin         string
	originTemplate string
	originA        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfof *mLoggerMockInfof) Optional() *mLoggerMockInfof {
	mmInfof.optional = true
	return mmInfof
}

// Expect sets up expected params for Logger.Infof
func (mmInfof *mLoggerMockInfof) Expect(template string, a ...any) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.paramPtrs != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by ExpectParams functions")
	}

	mmInfof.defaultExpectation.params = &LoggerMockInfofParams{template, a}
	mmInfof.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInfof.expectations {
		if minimock.Equal(e.params, mmInfof.defaultExpectation.params) {
			mmInfof.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfof.defaultExpectation.params)
		}
	}

	return mmInfof
}

// ExpectTemplateParam1 sets up expected param template for Logger.Infof
func (mmInfof *mLoggerMockInfof) ExpectTemplateParam1(template string) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.template = &template
	mmInfof.defaultExpectation.expectationOrigins.originTemplate = minimock.CallerInfo(1)

	return mmInfof
}

// ExpectAParam2 sets up expected param a for Logger.Infof
func (mmInfof *mLoggerMockInfof) ExpectAParam2(a ...any) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.a = &a
	mmInfof.defaultExpectation.expectationOrigins.originA = minimock.CallerInfo(1)

	return mmInfof
}

// Inspect accepts an inspector function that has same arguments as the Logger.Infof
func (mmInfof *mLoggerMockInfof) Inspect(f func(template string, a ...any)) *mLoggerMockInfof {
	if mmInfof.mock.inspectFuncInfof != nil {
		mmInfof.mock.t.Fatalf("Inspect function is already set for LoggerMock.Infof")
	}

	mmInfof.mock.inspectFuncInfof = f

	return mmInfof
}

// Return sets up results that will be returned by Logger.Infof
func (mmInfof *mLoggerMockInfof) Return() *LoggerMock {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{mock: mmInfof.mock}
	}

	mmInfof.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInfof.mock
}

// Set uses given function f to mock the Logger.Infof method
func (mmInfof *mLoggerMockInfof) Set(f func(template string, a ...any)) *LoggerMock {
	if mmInfof.defaultExpectation != nil {
		mmInfof.mock.t.Fatalf("Default expectation is already set for the Logger.Infof method")
	}

	if len(mmInfof.expectations) > 0 {
		mmInfof.mock.t.Fatalf("Some expectations are already set for the Logger.Infof method")
	}

	mmInfof.mock.funcInfof = f
	mmInfof.mock.funcInfofOrigin = minimock.CallerInfo(1)
	return mmInfof.mock
}

// When sets expectation for the Logger.Infof which will trigger the result defined by the following
// Then helper
func (mmInfof *mLoggerMockInfof) When(template string, a ...any) *LoggerMockInfofExpectation {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	expectation := &LoggerMockInfofExpectation{
		mock:               mmInfof.mock,
		params:             &LoggerMockInfofParams{template, a},
		expectationOrigins: LoggerMockInfofExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInfof.expectations = append(mmInfof.expectations, expectation)
	return expectation
}

// Then sets up Logger.Infof return parameters for the expectation previously defined by the When method

func (e *LoggerMockInfofExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Infof should be invoked
func (mmInfof *mLoggerMockInfof) Times(n uint64) *mLoggerMockInfof {
	if n == 0 {
		mmInfof.mock.t.Fatalf("Times of LoggerMock.Infof mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfof.expectedInvocations, n)
	mmInfof.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInfof
}

func (mmInfof *mLoggerMockInfof) invocationsDone() bool {
	if len(mmInfof.expectations) == 0 && mmInfof.defaultExpectation == nil && mmInfof.mock.funcInfof == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfof.mock.afterInfofCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfof.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Infof implements mm_contracts.Logger
func (mmInfof *LoggerMock) Infof(template string, a ...any) {
	mm_atomic.AddUint64(&mmInfof.beforeInfofCounter, 1)
	defer mm_atomic.AddUint64(&mmInfof.afterInfofCounter, 1)

	mmInfof.t.Helper()

	if mmInfof.inspectFuncInfof != nil {
		mmInfof.inspectFuncInfof(template, a...)
	}

	mm_params := LoggerMockInfofParams{template, a}

	// Record call args
	mmInfof.InfofMock.mutex.Lock()
	mmInfof.InfofMock.callArgs = append(mmInfof.InfofMock.callArgs, &mm_params)
	mmInfof.InfofMock.mutex.Unlock()

	for _, e := range mmInfof.InfofMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfof.InfofMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfof.InfofMock.defaultExpectation.Counter, 1)
		mm_want := mmInfof.InfofMock.defaultExpectation.params
		mm_want_ptrs := mmInfof.InfofMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfofParams{template, a}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.template != nil && !minimock.Equal(*mm_want_ptrs.template, mm_got.template) {
				mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameter template, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfof.InfofMock.defaultExpectation.expectationOrigins.originTemplate, *mm_want_ptrs.template, mm_got.template, minimock.Diff(*mm_want_ptrs.template, mm_got.template))
			}

			if mm_want_ptrs.a != nil && !minimock.Equal(*mm_want_ptrs.a, mm_got.a) {
				mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameter a, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfof.InfofMock.defaultExpectation.expectationOrigins.originA, *mm_want_ptrs.a, mm_got.a, minimock.Diff(*mm_want_ptrs.a, mm_got.a))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInfof.InfofMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfof.funcInfof != nil {
		mmInfof.funcInfof(template, a...)
		return
	}
	mmInfof.t.Fatalf("Unexpected call to LoggerMock.Infof. %v %v", template, a)

}

// InfofAfterCounter returns a count of finished LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.afterInfofCounter)
}

// InfofBeforeCounter returns a count of LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.beforeInfofCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Infof.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfof *mLoggerMockInfof) Calls() []*LoggerMockInfofParams {
	mmInfof.mutex.RLock()

	argCopy := make([]*LoggerMockInfofParams, len(mmInfof.callArgs))
	copy(argCopy, mmInfof.callArgs)

	mmInfof.mutex.RUnlock()

	return argCopy
}

// MinimockInfofDone returns true if the count of the Infof invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfofDone() bool {
	if m.InfofMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfofMock.invocationsDone()
}

// MinimockInfofInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfofInspect() {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Infof at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInfofCounter := mm_atomic.LoadUint64(&m.afterInfofCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && afterInfofCounter < 1 {
		if m.InfofMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Infof at\n%s", m.InfofMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Infof at\n%s with params: %#v", m.InfofMock.defaultExpectation.expectationOrigins.origin, *m.InfofMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && afterInfofCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Infof at\n%s", m.funcInfofOrigin)
	}

	if !m.InfofMock.invocationsDone() && afterInfofCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Infof at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InfofMock.expectedInvocations), m.InfofMock.expectedInvocationsOrigin, afterInfofCounter)
	}
}

type mLoggerMockPrint struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockPrintExpectation
	expectations       []*LoggerMockPrintExpectation

	callArgs []*LoggerMockPrintParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockPrintExpectation specifies expectation struct of the Logger.Print
type LoggerMockPrintExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockPrintParams
	paramPtrs          *LoggerMockPrintParamPtrs
	expectationOrigins LoggerMockPrintExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockPrintParams contains parameters of the Logger.Print
type LoggerMockPrintParams struct {
	msg     any
	keyvals []any
}

// LoggerMockPrintParamPtrs contains pointers to parameters of the Logger.Print
type LoggerMockPrintParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// LoggerMockPrintOrigins contains origins of expectations of the Logger.Print
type LoggerMockPrintExpectationOrigins struct {
	origin        string
	originMsg     string
	originKeyvals string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrint *mLoggerMockPrint) Optional() *mLoggerMockPrint {
	mmPrint.optional = true
	return mmPrint
}

// Expect sets up expected params for Logger.Print
func (mmPrint *mLoggerMockPrint) Expect(msg any, keyvals ...any) *mLoggerMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.paramPtrs != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by ExpectParams functions")
	}

	mmPrint.defaultExpectation.params = &LoggerMockPrintParams{msg, keyvals}
	mmPrint.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrint.expectations {
		if minimock.Equal(e.params, mmPrint.defaultExpectation.params) {
			mmPrint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrint.defaultExpectation.params)
		}
	}

	return mmPrint
}

// ExpectMsgParam1 sets up expected param msg for Logger.Print
func (mmPrint *mLoggerMockPrint) ExpectMsgParam1(msg any) *mLoggerMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.params != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Expect")
	}

	if mmPrint.defaultExpectation.paramPtrs == nil {
		mmPrint.defaultExpectation.paramPtrs = &LoggerMockPrintParamPtrs{}
	}
	mmPrint.defaultExpectation.paramPtrs.msg = &msg
	mmPrint.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmPrint
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Print
func (mmPrint *mLoggerMockPrint) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{}
	}

	if mmPrint.defaultExpectation.params != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Expect")
	}

	if mmPrint.defaultExpectation.paramPtrs == nil {
		mmPrint.defaultExpectation.paramPtrs = &LoggerMockPrintParamPtrs{}
	}
	mmPrint.defaultExpectation.paramPtrs.keyvals = &keyvals
	mmPrint.defaultExpectation.expectationOrigins.originKeyvals = minimock.CallerInfo(1)

	return mmPrint
}

// Inspect accepts an inspector function that has same arguments as the Logger.Print
func (mmPrint *mLoggerMockPrint) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockPrint {
	if mmPrint.mock.inspectFuncPrint != nil {
		mmPrint.mock.t.Fatalf("Inspect function is already set for LoggerMock.Print")
	}

	mmPrint.mock.inspectFuncPrint = f

	return mmPrint
}

// Return sets up results that will be returned by Logger.Print
func (mmPrint *mLoggerMockPrint) Return() *LoggerMock {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{mock: mmPrint.mock}
	}

	mmPrint.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrint.mock
}

// Set uses given function f to mock the Logger.Print method
func (mmPrint *mLoggerMockPrint) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmPrint.defaultExpectation != nil {
		mmPrint.mock.t.Fatalf("Default expectation is already set for the Logger.Print method")
	}

	if len(mmPrint.expectations) > 0 {
		mmPrint.mock.t.Fatalf("Some expectations are already set for the Logger.Print method")
	}

	mmPrint.mock.funcPrint = f
	mmPrint.mock.funcPrintOrigin = minimock.CallerInfo(1)
	return mmPrint.mock
}

// When sets expectation for the Logger.Print which will trigger the result defined by the following
// Then helper
func (mmPrint *mLoggerMockPrint) When(msg any, keyvals ...any) *LoggerMockPrintExpectation {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	expectation := &LoggerMockPrintExpectation{
		mock:               mmPrint.mock,
		params:             &LoggerMockPrintParams{msg, keyvals},
		expectationOrigins: LoggerMockPrintExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPrint.expectations = append(mmPrint.expectations, expectation)
	return expectation
}

// Then sets up Logger.Print return parameters for the expectation previously defined by the When method

func (e *LoggerMockPrintExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Print should be invoked
func (mmPrint *mLoggerMockPrint) Times(n uint64) *mLoggerMockPrint {
	if n == 0 {
		mmPrint.mock.t.Fatalf("Times of LoggerMock.Print mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrint.expectedInvocations, n)
	mmPrint.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrint
}

func (mmPrint *mLoggerMockPrint) invocationsDone() bool {
	if len(mmPrint.expectations) == 0 && mmPrint.defaultExpectation == nil && mmPrint.mock.funcPrint == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrint.mock.afterPrintCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrint.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Print implements mm_contracts.Logger
func (mmPrint *LoggerMock) Print(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmPrint.beforePrintCounter, 1)
	defer mm_atomic.AddUint64(&mmPrint.afterPrintCounter, 1)

	mmPrint.t.Helper()

	if mmPrint.inspectFuncPrint != nil {
		mmPrint.inspectFuncPrint(msg, keyvals...)
	}

	mm_params := LoggerMockPrintParams{msg, keyvals}

	// Record call args
	mmPrint.PrintMock.mutex.Lock()
	mmPrint.PrintMock.callArgs = append(mmPrint.PrintMock.callArgs, &mm_params)
	mmPrint.PrintMock.mutex.Unlock()

	for _, e := range mmPrint.PrintMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrint.PrintMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrint.PrintMock.defaultExpectation.Counter, 1)
		mm_want := mmPrint.PrintMock.defaultExpectation.params
		mm_want_ptrs := mmPrint.PrintMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockPrintParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmPrint.t.Errorf("LoggerMock.Print got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrint.PrintMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmPrint.t.Errorf("LoggerMock.Print got unexpected parameter keyvals, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrint.PrintMock.defaultExpectation.expectationOrigins.originKeyvals, *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrint.t.Errorf("LoggerMock.Print got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrint.PrintMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrint.funcPrint != nil {
		mmPrint.funcPrint(msg, keyvals...)
		return
	}
	mmPrint.t.Fatalf("Unexpected call to LoggerMock.Print. %v %v", msg, keyvals)

}

// PrintAfterCounter returns a count of finished LoggerMock.Print invocations
func (mmPrint *LoggerMock) PrintAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.afterPrintCounter)
}

// PrintBeforeCounter returns a count of LoggerMock.Print invocations
func (mmPrint *LoggerMock) PrintBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.beforePrintCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Print.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrint *mLoggerMockPrint) Calls() []*LoggerMockPrintParams {
	mmPrint.mutex.RLock()

	argCopy := make([]*LoggerMockPrintParams, len(mmPrint.callArgs))
	copy(argCopy, mmPrint.callArgs)

	mmPrint.mutex.RUnlock()

	return argCopy
}

// MinimockPrintDone returns true if the count of the Print invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPrintDone() bool {
	if m.PrintMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintMock.invocationsDone()
}

// MinimockPrintInspect logs each unmet expectation
func (m *LoggerMock) MinimockPrintInspect() {
	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Print at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrintCounter := mm_atomic.LoadUint64(&m.afterPrintCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintMock.defaultExpectation != nil && afterPrintCounter < 1 {
		if m.PrintMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Print at\n%s", m.PrintMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Print at\n%s with params: %#v", m.PrintMock.defaultExpectation.expectationOrigins.origin, *m.PrintMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrint != nil && afterPrintCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Print at\n%s", m.funcPrintOrigin)
	}

	if !m.PrintMock.invocationsDone() && afterPrintCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Print at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintMock.expectedInvocations), m.PrintMock.expectedInvocationsOrigin, afterPrintCounter)
	}
}

type mLoggerMockPrintf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockPrintfExpectation
	expectations       []*LoggerMockPrintfExpectation

	callArgs []*LoggerMockPrintfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockPrintfExpectation specifies expectation struct of the Logger.Printf
type LoggerMockPrintfExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockPrintfParams
	paramPtrs          *LoggerMockPrintfParamPtrs
	expectationOrigins LoggerMockPrintfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockPrintfParams contains parameters of the Logger.Printf
type LoggerMockPrintfParams struct {
	format string
	args   []any
}

// LoggerMockPrintfParamPtrs contains pointers to parameters of the Logger.Printf
type LoggerMockPrintfParamPtrs struct {
	format *string
	args   *[]any
}

// LoggerMockPrintfOrigins contains origins of expectations of the Logger.Printf
type LoggerMockPrintfExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrintf *mLoggerMockPrintf) Optional() *mLoggerMockPrintf {
	mmPrintf.optional = true
	return mmPrintf
}

// Expect sets up expected params for Logger.Printf
func (mmPrintf *mLoggerMockPrintf) Expect(format string, args ...any) *mLoggerMockPrintf {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{}
	}

	if mmPrintf.defaultExpectation.paramPtrs != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by ExpectParams functions")
	}

	mmPrintf.defaultExpectation.params = &LoggerMockPrintfParams{format, args}
	mmPrintf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrintf.expectations {
		if minimock.Equal(e.params, mmPrintf.defaultExpectation.params) {
			mmPrintf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintf.defaultExpectation.params)
		}
	}

	return mmPrintf
}

// ExpectFormatParam1 sets up expected param format for Logger.Printf
func (mmPrintf *mLoggerMockPrintf) ExpectFormatParam1(format string) *mLoggerMockPrintf {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{}
	}

	if mmPrintf.defaultExpectation.params != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Expect")
	}

	if mmPrintf.defaultExpectation.paramPtrs == nil {
		mmPrintf.defaultExpectation.paramPtrs = &LoggerMockPrintfParamPtrs{}
	}
	mmPrintf.defaultExpectation.paramPtrs.format = &format
	mmPrintf.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmPrintf
}

// ExpectArgsParam2 sets up expected param args for Logger.Printf
func (mmPrintf *mLoggerMockPrintf) ExpectArgsParam2(args ...any) *mLoggerMockPrintf {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{}
	}

	if mmPrintf.defaultExpectation.params != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Expect")
	}

	if mmPrintf.defaultExpectation.paramPtrs == nil {
		mmPrintf.defaultExpectation.paramPtrs = &LoggerMockPrintfParamPtrs{}
	}
	mmPrintf.defaultExpectation.paramPtrs.args = &args
	mmPrintf.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmPrintf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Printf
func (mmPrintf *mLoggerMockPrintf) Inspect(f func(format string, args ...any)) *mLoggerMockPrintf {
	if mmPrintf.mock.inspectFuncPrintf != nil {
		mmPrintf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Printf")
	}

	mmPrintf.mock.inspectFuncPrintf = f

	return mmPrintf
}

// Return sets up results that will be returned by Logger.Printf
func (mmPrintf *mLoggerMockPrintf) Return() *LoggerMock {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{mock: mmPrintf.mock}
	}

	mmPrintf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrintf.mock
}

// Set uses given function f to mock the Logger.Printf method
func (mmPrintf *mLoggerMockPrintf) Set(f func(format string, args ...any)) *LoggerMock {
	if mmPrintf.defaultExpectation != nil {
		mmPrintf.mock.t.Fatalf("Default expectation is already set for the Logger.Printf method")
	}

	if len(mmPrintf.expectations) > 0 {
		mmPrintf.mock.t.Fatalf("Some expectations are already set for the Logger.Printf method")
	}

	mmPrintf.mock.funcPrintf = f
	mmPrintf.mock.funcPrintfOrigin = minimock.CallerInfo(1)
	return mmPrintf.mock
}

// When sets expectation for the Logger.Printf which will trigger the result defined by the following
// Then helper
func (mmPrintf *mLoggerMockPrintf) When(format string, args ...any) *LoggerMockPrintfExpectation {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	expectation := &LoggerMockPrintfExpectation{
		mock:               mmPrintf.mock,
		params:             &LoggerMockPrintfParams{format, args},
		expectationOrigins: LoggerMockPrintfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPrintf.expectations = append(mmPrintf.expectations, expectation)
	return expectation
}

// Then sets up Logger.Printf return parameters for the expectation previously defined by the When method

func (e *LoggerMockPrintfExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Printf should be invoked
func (mmPrintf *mLoggerMockPrintf) Times(n uint64) *mLoggerMockPrintf {
	if n == 0 {
		mmPrintf.mock.t.Fatalf("Times of LoggerMock.Printf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrintf.expectedInvocations, n)
	mmPrintf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrintf
}

func (mmPrintf *mLoggerMockPrintf) invocationsDone() bool {
	if len(mmPrintf.expectations) == 0 && mmPrintf.defaultExpectation == nil && mmPrintf.mock.funcPrintf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrintf.mock.afterPrintfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrintf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Printf implements mm_contracts.Logger
func (mmPrintf *LoggerMock) Printf(format string, args ...any) {
	mm_atomic.AddUint64(&mmPrintf.beforePrintfCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintf.afterPrintfCounter, 1)

	mmPrintf.t.Helper()

	if mmPrintf.inspectFuncPrintf != nil {
		mmPrintf.inspectFuncPrintf(format, args...)
	}

	mm_params := LoggerMockPrintfParams{format, args}

	// Record call args
	mmPrintf.PrintfMock.mutex.Lock()
	mmPrintf.PrintfMock.callArgs = append(mmPrintf.PrintfMock.callArgs, &mm_params)
	mmPrintf.PrintfMock.mutex.Unlock()

	for _, e := range mmPrintf.PrintfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrintf.PrintfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintf.PrintfMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintf.PrintfMock.defaultExpectation.params
		mm_want_ptrs := mmPrintf.PrintfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockPrintfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmPrintf.t.Errorf("LoggerMock.Printf got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrintf.PrintfMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmPrintf.t.Errorf("LoggerMock.Printf got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrintf.PrintfMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintf.t.Errorf("LoggerMock.Printf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrintf.PrintfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrintf.funcPrintf != nil {
		mmPrintf.funcPrintf(format, args...)
		return
	}
	mmPrintf.t.Fatalf("Unexpected call to LoggerMock.Printf. %v %v", format, args)

}

// PrintfAfterCounter returns a count of finished LoggerMock.Printf invocations
func (mmPrintf *LoggerMock) PrintfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintf.afterPrintfCounter)
}

// PrintfBeforeCounter returns a count of LoggerMock.Printf invocations
func (mmPrintf *LoggerMock) PrintfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintf.beforePrintfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Printf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintf *mLoggerMockPrintf) Calls() []*LoggerMockPrintfParams {
	mmPrintf.mutex.RLock()

	argCopy := make([]*LoggerMockPrintfParams, len(mmPrintf.callArgs))
	copy(argCopy, mmPrintf.callArgs)

	mmPrintf.mutex.RUnlock()

	return argCopy
}

// MinimockPrintfDone returns true if the count of the Printf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPrintfDone() bool {
	if m.PrintfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrintfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrintfMock.invocationsDone()
}

// MinimockPrintfInspect logs each unmet expectation
func (m *LoggerMock) MinimockPrintfInspect() {
	for _, e := range m.PrintfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Printf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrintfCounter := mm_atomic.LoadUint64(&m.afterPrintfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrintfMock.defaultExpectation != nil && afterPrintfCounter < 1 {
		if m.PrintfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Printf at\n%s", m.PrintfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Printf at\n%s with params: %#v", m.PrintfMock.defaultExpectation.expectationOrigins.origin, *m.PrintfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintf != nil && afterPrintfCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Printf at\n%s", m.funcPrintfOrigin)
	}

	if !m.PrintfMock.invocationsDone() && afterPrintfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Printf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrintfMock.expectedInvocations), m.PrintfMock.expectedInvocationsOrigin, afterPrintfCounter)
	}
}

type mLoggerMockWarn struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnExpectation
	expectations       []*LoggerMockWarnExpectation

	callArgs []*LoggerMockWarnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockWarnExpectation specifies expectation struct of the Logger.Warn
type LoggerMockWarnExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockWarnParams
	paramPtrs          *LoggerMockWarnParamPtrs
	expectationOrigins LoggerMockWarnExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockWarnParams contains parameters of the Logger.Warn
type LoggerMockWarnParams struct {
	msg     any
	keyvals []any
}

// LoggerMockWarnParamPtrs contains pointers to parameters of the Logger.Warn
type LoggerMockWarnParamPtrs struct {
	msg     *any
	keyvals *[]any
}

// LoggerMockWarnOrigins contains origins of expectations of the Logger.Warn
type LoggerMockWarnExpectationOrigins struct {
	origin        string
	originMsg     string
	originKeyvals string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarn *mLoggerMockWarn) Optional() *mLoggerMockWarn {
	mmWarn.optional = true
	return mmWarn
}

// Expect sets up expected params for Logger.Warn
func (mmWarn *mLoggerMockWarn) Expect(msg any, keyvals ...any) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.paramPtrs != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by ExpectParams functions")
	}

	mmWarn.defaultExpectation.params = &LoggerMockWarnParams{msg, keyvals}
	mmWarn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// ExpectMsgParam1 sets up expected param msg for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectMsgParam1(msg any) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.msg = &msg
	mmWarn.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmWarn
}

// ExpectKeyvalsParam2 sets up expected param keyvals for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectKeyvalsParam2(keyvals ...any) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.keyvals = &keyvals
	mmWarn.defaultExpectation.expectationOrigins.originKeyvals = minimock.CallerInfo(1)

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warn
func (mmWarn *mLoggerMockWarn) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Logger.Warn
func (mmWarn *mLoggerMockWarn) Return() *LoggerMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{mock: mmWarn.mock}
	}

	mmWarn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// Set uses given function f to mock the Logger.Warn method
func (mmWarn *mLoggerMockWarn) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Logger.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Logger.Warn method")
	}

	mmWarn.mock.funcWarn = f
	mmWarn.mock.funcWarnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// When sets expectation for the Logger.Warn which will trigger the result defined by the following
// Then helper
func (mmWarn *mLoggerMockWarn) When(msg any, keyvals ...any) *LoggerMockWarnExpectation {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	expectation := &LoggerMockWarnExpectation{
		mock:               mmWarn.mock,
		params:             &LoggerMockWarnParams{msg, keyvals},
		expectationOrigins: LoggerMockWarnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWarn.expectations = append(mmWarn.expectations, expectation)
	return expectation
}

// Then sets up Logger.Warn return parameters for the expectation previously defined by the When method

func (e *LoggerMockWarnExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Warn should be invoked
func (mmWarn *mLoggerMockWarn) Times(n uint64) *mLoggerMockWarn {
	if n == 0 {
		mmWarn.mock.t.Fatalf("Times of LoggerMock.Warn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarn.expectedInvocations, n)
	mmWarn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWarn
}

func (mmWarn *mLoggerMockWarn) invocationsDone() bool {
	if len(mmWarn.expectations) == 0 && mmWarn.defaultExpectation == nil && mmWarn.mock.funcWarn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarn.mock.afterWarnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warn implements mm_contracts.Logger
func (mmWarn *LoggerMock) Warn(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	mmWarn.t.Helper()

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(msg, keyvals...)
	}

	mm_params := LoggerMockWarnParams{msg, keyvals}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, &mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_want_ptrs := mmWarn.WarnMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnParams{msg, keyvals}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.keyvals != nil && !minimock.Equal(*mm_want_ptrs.keyvals, mm_got.keyvals) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter keyvals, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originKeyvals, *mm_want_ptrs.keyvals, mm_got.keyvals, minimock.Diff(*mm_want_ptrs.keyvals, mm_got.keyvals))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWarn.WarnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(msg, keyvals...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerMock.Warn. %v %v", msg, keyvals)

}

// WarnAfterCounter returns a count of finished LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerMockWarn) Calls() []*LoggerMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnDone() bool {
	if m.WarnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnMock.invocationsDone()
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWarnCounter := mm_atomic.LoadUint64(&m.afterWarnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && afterWarnCounter < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s", m.WarnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s with params: %#v", m.WarnMock.defaultExpectation.expectationOrigins.origin, *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && afterWarnCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Warn at\n%s", m.funcWarnOrigin)
	}

	if !m.WarnMock.invocationsDone() && afterWarnCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WarnMock.expectedInvocations), m.WarnMock.expectedInvocationsOrigin, afterWarnCounter)
	}
}

type mLoggerMockWarnf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnfExpectation
	expectations       []*LoggerMockWarnfExpectation

	callArgs []*LoggerMockWarnfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockWarnfExpectation specifies expectation struct of the Logger.Warnf
type LoggerMockWarnfExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockWarnfParams
	paramPtrs          *LoggerMockWarnfParamPtrs
	expectationOrigins LoggerMockWarnfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockWarnfParams contains parameters of the Logger.Warnf
type LoggerMockWarnfParams struct {
	template string
	a        []any
}

// LoggerMockWarnfParamPtrs contains pointers to parameters of the Logger.Warnf
type LoggerMockWarnfParamPtrs struct {
	template *string
	a        *[]any
}

// LoggerMockWarnfOrigins contains origins of expectations of the Logger.Warnf
type LoggerMockWarnfExpectationOrigins struct {
	origin         string
	originTemplate string
	originA        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarnf *mLoggerMockWarnf) Optional() *mLoggerMockWarnf {
	mmWarnf.optional = true
	return mmWarnf
}

// Expect sets up expected params for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Expect(template string, a ...any) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.paramPtrs != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by ExpectParams functions")
	}

	mmWarnf.defaultExpectation.params = &LoggerMockWarnfParams{template, a}
	mmWarnf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWarnf.expectations {
		if minimock.Equal(e.params, mmWarnf.defaultExpectation.params) {
			mmWarnf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarnf.defaultExpectation.params)
		}
	}

	return mmWarnf
}

// ExpectTemplateParam1 sets up expected param template for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) ExpectTemplateParam1(template string) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.template = &template
	mmWarnf.defaultExpectation.expectationOrigins.originTemplate = minimock.CallerInfo(1)

	return mmWarnf
}

// ExpectAParam2 sets up expected param a for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) ExpectAParam2(a ...any) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.a = &a
	mmWarnf.defaultExpectation.expectationOrigins.originA = minimock.CallerInfo(1)

	return mmWarnf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Inspect(f func(template string, a ...any)) *mLoggerMockWarnf {
	if mmWarnf.mock.inspectFuncWarnf != nil {
		mmWarnf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warnf")
	}

	mmWarnf.mock.inspectFuncWarnf = f

	return mmWarnf
}

// Return sets up results that will be returned by Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Return() *LoggerMock {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{mock: mmWarnf.mock}
	}

	mmWarnf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWarnf.mock
}

// Set uses given function f to mock the Logger.Warnf method
func (mmWarnf *mLoggerMockWarnf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmWarnf.defaultExpectation != nil {
		mmWarnf.mock.t.Fatalf("Default expectation is already set for the Logger.Warnf method")
	}

	if len(mmWarnf.expectations) > 0 {
		mmWarnf.mock.t.Fatalf("Some expectations are already set for the Logger.Warnf method")
	}

	mmWarnf.mock.funcWarnf = f
	mmWarnf.mock.funcWarnfOrigin = minimock.CallerInfo(1)
	return mmWarnf.mock
}

// When sets expectation for the Logger.Warnf which will trigger the result defined by the following
// Then helper
func (mmWarnf *mLoggerMockWarnf) When(template string, a ...any) *LoggerMockWarnfExpectation {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	expectation := &LoggerMockWarnfExpectation{
		mock:               mmWarnf.mock,
		params:             &LoggerMockWarnfParams{template, a},
		expectationOrigins: LoggerMockWarnfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWarnf.expectations = append(mmWarnf.expectations, expectation)
	return expectation
}

// Then sets up Logger.Warnf return parameters for the expectation previously defined by the When method

func (e *LoggerMockWarnfExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Warnf should be invoked
func (mmWarnf *mLoggerMockWarnf) Times(n uint64) *mLoggerMockWarnf {
	if n == 0 {
		mmWarnf.mock.t.Fatalf("Times of LoggerMock.Warnf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarnf.expectedInvocations, n)
	mmWarnf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWarnf
}

func (mmWarnf *mLoggerMockWarnf) invocationsDone() bool {
	if len(mmWarnf.expectations) == 0 && mmWarnf.defaultExpectation == nil && mmWarnf.mock.funcWarnf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarnf.mock.afterWarnfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarnf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warnf implements mm_contracts.Logger
func (mmWarnf *LoggerMock) Warnf(template string, a ...any) {
	mm_atomic.AddUint64(&mmWarnf.beforeWarnfCounter, 1)
	defer mm_atomic.AddUint64(&mmWarnf.afterWarnfCounter, 1)

	mmWarnf.t.Helper()

	if mmWarnf.inspectFuncWarnf != nil {
		mmWarnf.inspectFuncWarnf(template, a...)
	}

	mm_params := LoggerMockWarnfParams{template, a}

	// Record call args
	mmWarnf.WarnfMock.mutex.Lock()
	mmWarnf.WarnfMock.callArgs = append(mmWarnf.WarnfMock.callArgs, &mm_params)
	mmWarnf.WarnfMock.mutex.Unlock()

	for _, e := range mmWarnf.WarnfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarnf.WarnfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarnf.WarnfMock.defaultExpectation.Counter, 1)
		mm_want := mmWarnf.WarnfMock.defaultExpectation.params
		mm_want_ptrs := mmWarnf.WarnfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnfParams{template, a}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.template != nil && !minimock.Equal(*mm_want_ptrs.template, mm_got.template) {
				mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameter template, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarnf.WarnfMock.defaultExpectation.expectationOrigins.originTemplate, *mm_want_ptrs.template, mm_got.template, minimock.Diff(*mm_want_ptrs.template, mm_got.template))
			}

			if mm_want_ptrs.a != nil && !minimock.Equal(*mm_want_ptrs.a, mm_got.a) {
				mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameter a, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarnf.WarnfMock.defaultExpectation.expectationOrigins.originA, *mm_want_ptrs.a, mm_got.a, minimock.Diff(*mm_want_ptrs.a, mm_got.a))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWarnf.WarnfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarnf.funcWarnf != nil {
		mmWarnf.funcWarnf(template, a...)
		return
	}
	mmWarnf.t.Fatalf("Unexpected call to LoggerMock.Warnf. %v %v", template, a)

}

// WarnfAfterCounter returns a count of finished LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.afterWarnfCounter)
}

// WarnfBeforeCounter returns a count of LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.beforeWarnfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warnf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarnf *mLoggerMockWarnf) Calls() []*LoggerMockWarnfParams {
	mmWarnf.mutex.RLock()

	argCopy := make([]*LoggerMockWarnfParams, len(mmWarnf.callArgs))
	copy(argCopy, mmWarnf.callArgs)

	mmWarnf.mutex.RUnlock()

	return argCopy
}

// MinimockWarnfDone returns true if the count of the Warnf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnfDone() bool {
	if m.WarnfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnfMock.invocationsDone()
}

// MinimockWarnfInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnfInspect() {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warnf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWarnfCounter := mm_atomic.LoadUint64(&m.afterWarnfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && afterWarnfCounter < 1 {
		if m.WarnfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Warnf at\n%s", m.WarnfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warnf at\n%s with params: %#v", m.WarnfMock.defaultExpectation.expectationOrigins.origin, *m.WarnfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && afterWarnfCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Warnf at\n%s", m.funcWarnfOrigin)
	}

	if !m.WarnfMock.invocationsDone() && afterWarnfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warnf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WarnfMock.expectedInvocations), m.WarnfMock.expectedInvocationsOrigin, afterWarnfCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDebugInspect()

			m.MinimockDebugfInspect()

			m.MinimockErrorInspect()

			m.MinimockErrorfInspect()

			m.MinimockInfoInspect()

			m.MinimockInfofInspect()

			m.MinimockPrintInspect()

			m.MinimockPrintfInspect()

			m.MinimockWarnInspect()

			m.MinimockWarnfInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockDebugfDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockInfoDone() &&
		m.MinimockInfofDone() &&
		m.MinimockPrintDone() &&
		m.MinimockPrintfDone() &&
		m.MinimockWarnDone() &&
		m.MinimockWarnfDone()
}
