// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/evg4b/uncors/internal/contracts.Logger -o logger_mock.go -n LoggerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoggerMock implements contracts.Logger
type LoggerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDebug          func(msg any, keyvals ...any)
	inspectFuncDebug   func(msg any, keyvals ...any)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcDebugf          func(template string, a ...any)
	inspectFuncDebugf   func(template string, a ...any)
	afterDebugfCounter  uint64
	beforeDebugfCounter uint64
	DebugfMock          mLoggerMockDebugf

	funcError          func(msg any, keyvals ...any)
	inspectFuncError   func(msg any, keyvals ...any)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcErrorf          func(template string, a ...any)
	inspectFuncErrorf   func(template string, a ...any)
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mLoggerMockErrorf

	funcInfo          func(msg any, keyvals ...any)
	inspectFuncInfo   func(msg any, keyvals ...any)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcInfof          func(template string, a ...any)
	inspectFuncInfof   func(template string, a ...any)
	afterInfofCounter  uint64
	beforeInfofCounter uint64
	InfofMock          mLoggerMockInfof

	funcPrint          func(msg any, keyvals ...any)
	inspectFuncPrint   func(msg any, keyvals ...any)
	afterPrintCounter  uint64
	beforePrintCounter uint64
	PrintMock          mLoggerMockPrint

	funcPrintf          func(format string, args ...any)
	inspectFuncPrintf   func(format string, args ...any)
	afterPrintfCounter  uint64
	beforePrintfCounter uint64
	PrintfMock          mLoggerMockPrintf

	funcWarn          func(msg any, keyvals ...any)
	inspectFuncWarn   func(msg any, keyvals ...any)
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerMockWarn

	funcWarnf          func(template string, a ...any)
	inspectFuncWarnf   func(template string, a ...any)
	afterWarnfCounter  uint64
	beforeWarnfCounter uint64
	WarnfMock          mLoggerMockWarnf
}

// NewLoggerMock returns a mock for contracts.Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.DebugfMock = mLoggerMockDebugf{mock: m}
	m.DebugfMock.callArgs = []*LoggerMockDebugfParams{}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.ErrorfMock = mLoggerMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*LoggerMockErrorfParams{}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.InfofMock = mLoggerMockInfof{mock: m}
	m.InfofMock.callArgs = []*LoggerMockInfofParams{}

	m.PrintMock = mLoggerMockPrint{mock: m}
	m.PrintMock.callArgs = []*LoggerMockPrintParams{}

	m.PrintfMock = mLoggerMockPrintf{mock: m}
	m.PrintfMock.callArgs = []*LoggerMockPrintfParams{}

	m.WarnMock = mLoggerMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerMockWarnParams{}

	m.WarnfMock = mLoggerMockWarnf{mock: m}
	m.WarnfMock.callArgs = []*LoggerMockWarnfParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerMockDebug struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock   *LoggerMock
	params *LoggerMockDebugParams

	Counter uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	msg     any
	keyvals []any
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(msg any, keyvals ...any) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{msg, keyvals}
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	return mmDebug.mock
}

// Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	return mmDebug.mock
}

// Debug implements contracts.Logger
func (mmDebug *LoggerMock) Debug(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(msg, keyvals...)
	}

	mm_params := LoggerMockDebugParams{msg, keyvals}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, &mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_got := LoggerMockDebugParams{msg, keyvals}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(msg, keyvals...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v %v", msg, keyvals)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debug")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Debug")
	}
}

type mLoggerMockDebugf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugfExpectation
	expectations       []*LoggerMockDebugfExpectation

	callArgs []*LoggerMockDebugfParams
	mutex    sync.RWMutex
}

// LoggerMockDebugfExpectation specifies expectation struct of the Logger.Debugf
type LoggerMockDebugfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockDebugfParams

	Counter uint64
}

// LoggerMockDebugfParams contains parameters of the Logger.Debugf
type LoggerMockDebugfParams struct {
	template string
	a        []any
}

// Expect sets up expected params for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Expect(template string, a ...any) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	mmDebugf.defaultExpectation.params = &LoggerMockDebugfParams{template, a}
	for _, e := range mmDebugf.expectations {
		if minimock.Equal(e.params, mmDebugf.defaultExpectation.params) {
			mmDebugf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugf.defaultExpectation.params)
		}
	}

	return mmDebugf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Inspect(f func(template string, a ...any)) *mLoggerMockDebugf {
	if mmDebugf.mock.inspectFuncDebugf != nil {
		mmDebugf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debugf")
	}

	mmDebugf.mock.inspectFuncDebugf = f

	return mmDebugf
}

// Return sets up results that will be returned by Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Return() *LoggerMock {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{mock: mmDebugf.mock}
	}

	return mmDebugf.mock
}

// Set uses given function f to mock the Logger.Debugf method
func (mmDebugf *mLoggerMockDebugf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmDebugf.defaultExpectation != nil {
		mmDebugf.mock.t.Fatalf("Default expectation is already set for the Logger.Debugf method")
	}

	if len(mmDebugf.expectations) > 0 {
		mmDebugf.mock.t.Fatalf("Some expectations are already set for the Logger.Debugf method")
	}

	mmDebugf.mock.funcDebugf = f
	return mmDebugf.mock
}

// Debugf implements contracts.Logger
func (mmDebugf *LoggerMock) Debugf(template string, a ...any) {
	mm_atomic.AddUint64(&mmDebugf.beforeDebugfCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugf.afterDebugfCounter, 1)

	if mmDebugf.inspectFuncDebugf != nil {
		mmDebugf.inspectFuncDebugf(template, a...)
	}

	mm_params := LoggerMockDebugfParams{template, a}

	// Record call args
	mmDebugf.DebugfMock.mutex.Lock()
	mmDebugf.DebugfMock.callArgs = append(mmDebugf.DebugfMock.callArgs, &mm_params)
	mmDebugf.DebugfMock.mutex.Unlock()

	for _, e := range mmDebugf.DebugfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugf.DebugfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugf.DebugfMock.defaultExpectation.Counter, 1)
		mm_want := mmDebugf.DebugfMock.defaultExpectation.params
		mm_got := LoggerMockDebugfParams{template, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebugf.funcDebugf != nil {
		mmDebugf.funcDebugf(template, a...)
		return
	}
	mmDebugf.t.Fatalf("Unexpected call to LoggerMock.Debugf. %v %v", template, a)

}

// DebugfAfterCounter returns a count of finished LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.afterDebugfCounter)
}

// DebugfBeforeCounter returns a count of LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.beforeDebugfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debugf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugf *mLoggerMockDebugf) Calls() []*LoggerMockDebugfParams {
	mmDebugf.mutex.RLock()

	argCopy := make([]*LoggerMockDebugfParams, len(mmDebugf.callArgs))
	copy(argCopy, mmDebugf.callArgs)

	mmDebugf.mutex.RUnlock()

	return argCopy
}

// MinimockDebugfDone returns true if the count of the Debugf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugfDone() bool {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugfInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugfInspect() {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		if m.DebugfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debugf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *m.DebugfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Debugf")
	}
}

type mLoggerMockError struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock   *LoggerMock
	params *LoggerMockErrorParams

	Counter uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	msg     any
	keyvals []any
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(msg any, keyvals ...any) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{msg, keyvals}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

// Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Error implements contracts.Logger
func (mmError *LoggerMock) Error(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(msg, keyvals...)
	}

	mm_params := LoggerMockErrorParams{msg, keyvals}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, &mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_got := LoggerMockErrorParams{msg, keyvals}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(msg, keyvals...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v %v", msg, keyvals)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Error")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Error")
	}
}

type mLoggerMockErrorf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorfExpectation
	expectations       []*LoggerMockErrorfExpectation

	callArgs []*LoggerMockErrorfParams
	mutex    sync.RWMutex
}

// LoggerMockErrorfExpectation specifies expectation struct of the Logger.Errorf
type LoggerMockErrorfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockErrorfParams

	Counter uint64
}

// LoggerMockErrorfParams contains parameters of the Logger.Errorf
type LoggerMockErrorfParams struct {
	template string
	a        []any
}

// Expect sets up expected params for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Expect(template string, a ...any) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	mmErrorf.defaultExpectation.params = &LoggerMockErrorfParams{template, a}
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Inspect(f func(template string, a ...any)) *mLoggerMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Return() *LoggerMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{mock: mmErrorf.mock}
	}

	return mmErrorf.mock
}

// Set uses given function f to mock the Logger.Errorf method
func (mmErrorf *mLoggerMockErrorf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the Logger.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the Logger.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	return mmErrorf.mock
}

// Errorf implements contracts.Logger
func (mmErrorf *LoggerMock) Errorf(template string, a ...any) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(template, a...)
	}

	mm_params := LoggerMockErrorfParams{template, a}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, &mm_params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorf.ErrorfMock.defaultExpectation.params
		mm_got := LoggerMockErrorfParams{template, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(template, a...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to LoggerMock.Errorf. %v %v", template, a)

}

// ErrorfAfterCounter returns a count of finished LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mLoggerMockErrorf) Calls() []*LoggerMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*LoggerMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorfDone() bool {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorfInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Errorf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Errorf")
	}
}

type mLoggerMockInfo struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock   *LoggerMock
	params *LoggerMockInfoParams

	Counter uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	msg     any
	keyvals []any
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(msg any, keyvals ...any) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{msg, keyvals}
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	return mmInfo.mock
}

// Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	return mmInfo.mock
}

// Info implements contracts.Logger
func (mmInfo *LoggerMock) Info(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(msg, keyvals...)
	}

	mm_params := LoggerMockInfoParams{msg, keyvals}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, &mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_got := LoggerMockInfoParams{msg, keyvals}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(msg, keyvals...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v %v", msg, keyvals)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Info")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Info")
	}
}

type mLoggerMockInfof struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfofExpectation
	expectations       []*LoggerMockInfofExpectation

	callArgs []*LoggerMockInfofParams
	mutex    sync.RWMutex
}

// LoggerMockInfofExpectation specifies expectation struct of the Logger.Infof
type LoggerMockInfofExpectation struct {
	mock   *LoggerMock
	params *LoggerMockInfofParams

	Counter uint64
}

// LoggerMockInfofParams contains parameters of the Logger.Infof
type LoggerMockInfofParams struct {
	template string
	a        []any
}

// Expect sets up expected params for Logger.Infof
func (mmInfof *mLoggerMockInfof) Expect(template string, a ...any) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	mmInfof.defaultExpectation.params = &LoggerMockInfofParams{template, a}
	for _, e := range mmInfof.expectations {
		if minimock.Equal(e.params, mmInfof.defaultExpectation.params) {
			mmInfof.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfof.defaultExpectation.params)
		}
	}

	return mmInfof
}

// Inspect accepts an inspector function that has same arguments as the Logger.Infof
func (mmInfof *mLoggerMockInfof) Inspect(f func(template string, a ...any)) *mLoggerMockInfof {
	if mmInfof.mock.inspectFuncInfof != nil {
		mmInfof.mock.t.Fatalf("Inspect function is already set for LoggerMock.Infof")
	}

	mmInfof.mock.inspectFuncInfof = f

	return mmInfof
}

// Return sets up results that will be returned by Logger.Infof
func (mmInfof *mLoggerMockInfof) Return() *LoggerMock {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{mock: mmInfof.mock}
	}

	return mmInfof.mock
}

// Set uses given function f to mock the Logger.Infof method
func (mmInfof *mLoggerMockInfof) Set(f func(template string, a ...any)) *LoggerMock {
	if mmInfof.defaultExpectation != nil {
		mmInfof.mock.t.Fatalf("Default expectation is already set for the Logger.Infof method")
	}

	if len(mmInfof.expectations) > 0 {
		mmInfof.mock.t.Fatalf("Some expectations are already set for the Logger.Infof method")
	}

	mmInfof.mock.funcInfof = f
	return mmInfof.mock
}

// Infof implements contracts.Logger
func (mmInfof *LoggerMock) Infof(template string, a ...any) {
	mm_atomic.AddUint64(&mmInfof.beforeInfofCounter, 1)
	defer mm_atomic.AddUint64(&mmInfof.afterInfofCounter, 1)

	if mmInfof.inspectFuncInfof != nil {
		mmInfof.inspectFuncInfof(template, a...)
	}

	mm_params := LoggerMockInfofParams{template, a}

	// Record call args
	mmInfof.InfofMock.mutex.Lock()
	mmInfof.InfofMock.callArgs = append(mmInfof.InfofMock.callArgs, &mm_params)
	mmInfof.InfofMock.mutex.Unlock()

	for _, e := range mmInfof.InfofMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfof.InfofMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfof.InfofMock.defaultExpectation.Counter, 1)
		mm_want := mmInfof.InfofMock.defaultExpectation.params
		mm_got := LoggerMockInfofParams{template, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfof.funcInfof != nil {
		mmInfof.funcInfof(template, a...)
		return
	}
	mmInfof.t.Fatalf("Unexpected call to LoggerMock.Infof. %v %v", template, a)

}

// InfofAfterCounter returns a count of finished LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.afterInfofCounter)
}

// InfofBeforeCounter returns a count of LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.beforeInfofCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Infof.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfof *mLoggerMockInfof) Calls() []*LoggerMockInfofParams {
	mmInfof.mutex.RLock()

	argCopy := make([]*LoggerMockInfofParams, len(mmInfof.callArgs))
	copy(argCopy, mmInfof.callArgs)

	mmInfof.mutex.RUnlock()

	return argCopy
}

// MinimockInfofDone returns true if the count of the Infof invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfofDone() bool {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfofInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfofInspect() {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		if m.InfofMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Infof")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *m.InfofMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Infof")
	}
}

type mLoggerMockPrint struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockPrintExpectation
	expectations       []*LoggerMockPrintExpectation

	callArgs []*LoggerMockPrintParams
	mutex    sync.RWMutex
}

// LoggerMockPrintExpectation specifies expectation struct of the Logger.Print
type LoggerMockPrintExpectation struct {
	mock   *LoggerMock
	params *LoggerMockPrintParams

	Counter uint64
}

// LoggerMockPrintParams contains parameters of the Logger.Print
type LoggerMockPrintParams struct {
	msg     any
	keyvals []any
}

// Expect sets up expected params for Logger.Print
func (mmPrint *mLoggerMockPrint) Expect(msg any, keyvals ...any) *mLoggerMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{}
	}

	mmPrint.defaultExpectation.params = &LoggerMockPrintParams{msg, keyvals}
	for _, e := range mmPrint.expectations {
		if minimock.Equal(e.params, mmPrint.defaultExpectation.params) {
			mmPrint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrint.defaultExpectation.params)
		}
	}

	return mmPrint
}

// Inspect accepts an inspector function that has same arguments as the Logger.Print
func (mmPrint *mLoggerMockPrint) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockPrint {
	if mmPrint.mock.inspectFuncPrint != nil {
		mmPrint.mock.t.Fatalf("Inspect function is already set for LoggerMock.Print")
	}

	mmPrint.mock.inspectFuncPrint = f

	return mmPrint
}

// Return sets up results that will be returned by Logger.Print
func (mmPrint *mLoggerMockPrint) Return() *LoggerMock {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("LoggerMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &LoggerMockPrintExpectation{mock: mmPrint.mock}
	}

	return mmPrint.mock
}

// Set uses given function f to mock the Logger.Print method
func (mmPrint *mLoggerMockPrint) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmPrint.defaultExpectation != nil {
		mmPrint.mock.t.Fatalf("Default expectation is already set for the Logger.Print method")
	}

	if len(mmPrint.expectations) > 0 {
		mmPrint.mock.t.Fatalf("Some expectations are already set for the Logger.Print method")
	}

	mmPrint.mock.funcPrint = f
	return mmPrint.mock
}

// Print implements contracts.Logger
func (mmPrint *LoggerMock) Print(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmPrint.beforePrintCounter, 1)
	defer mm_atomic.AddUint64(&mmPrint.afterPrintCounter, 1)

	if mmPrint.inspectFuncPrint != nil {
		mmPrint.inspectFuncPrint(msg, keyvals...)
	}

	mm_params := LoggerMockPrintParams{msg, keyvals}

	// Record call args
	mmPrint.PrintMock.mutex.Lock()
	mmPrint.PrintMock.callArgs = append(mmPrint.PrintMock.callArgs, &mm_params)
	mmPrint.PrintMock.mutex.Unlock()

	for _, e := range mmPrint.PrintMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrint.PrintMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrint.PrintMock.defaultExpectation.Counter, 1)
		mm_want := mmPrint.PrintMock.defaultExpectation.params
		mm_got := LoggerMockPrintParams{msg, keyvals}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrint.t.Errorf("LoggerMock.Print got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrint.funcPrint != nil {
		mmPrint.funcPrint(msg, keyvals...)
		return
	}
	mmPrint.t.Fatalf("Unexpected call to LoggerMock.Print. %v %v", msg, keyvals)

}

// PrintAfterCounter returns a count of finished LoggerMock.Print invocations
func (mmPrint *LoggerMock) PrintAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.afterPrintCounter)
}

// PrintBeforeCounter returns a count of LoggerMock.Print invocations
func (mmPrint *LoggerMock) PrintBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.beforePrintCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Print.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrint *mLoggerMockPrint) Calls() []*LoggerMockPrintParams {
	mmPrint.mutex.RLock()

	argCopy := make([]*LoggerMockPrintParams, len(mmPrint.callArgs))
	copy(argCopy, mmPrint.callArgs)

	mmPrint.mutex.RUnlock()

	return argCopy
}

// MinimockPrintDone returns true if the count of the Print invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPrintDone() bool {
	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrint != nil && mm_atomic.LoadUint64(&m.afterPrintCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrintInspect logs each unmet expectation
func (m *LoggerMock) MinimockPrintInspect() {
	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Print with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintCounter) < 1 {
		if m.PrintMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Print")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Print with params: %#v", *m.PrintMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrint != nil && mm_atomic.LoadUint64(&m.afterPrintCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Print")
	}
}

type mLoggerMockPrintf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockPrintfExpectation
	expectations       []*LoggerMockPrintfExpectation

	callArgs []*LoggerMockPrintfParams
	mutex    sync.RWMutex
}

// LoggerMockPrintfExpectation specifies expectation struct of the Logger.Printf
type LoggerMockPrintfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockPrintfParams

	Counter uint64
}

// LoggerMockPrintfParams contains parameters of the Logger.Printf
type LoggerMockPrintfParams struct {
	format string
	args   []any
}

// Expect sets up expected params for Logger.Printf
func (mmPrintf *mLoggerMockPrintf) Expect(format string, args ...any) *mLoggerMockPrintf {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{}
	}

	mmPrintf.defaultExpectation.params = &LoggerMockPrintfParams{format, args}
	for _, e := range mmPrintf.expectations {
		if minimock.Equal(e.params, mmPrintf.defaultExpectation.params) {
			mmPrintf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintf.defaultExpectation.params)
		}
	}

	return mmPrintf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Printf
func (mmPrintf *mLoggerMockPrintf) Inspect(f func(format string, args ...any)) *mLoggerMockPrintf {
	if mmPrintf.mock.inspectFuncPrintf != nil {
		mmPrintf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Printf")
	}

	mmPrintf.mock.inspectFuncPrintf = f

	return mmPrintf
}

// Return sets up results that will be returned by Logger.Printf
func (mmPrintf *mLoggerMockPrintf) Return() *LoggerMock {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("LoggerMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &LoggerMockPrintfExpectation{mock: mmPrintf.mock}
	}

	return mmPrintf.mock
}

// Set uses given function f to mock the Logger.Printf method
func (mmPrintf *mLoggerMockPrintf) Set(f func(format string, args ...any)) *LoggerMock {
	if mmPrintf.defaultExpectation != nil {
		mmPrintf.mock.t.Fatalf("Default expectation is already set for the Logger.Printf method")
	}

	if len(mmPrintf.expectations) > 0 {
		mmPrintf.mock.t.Fatalf("Some expectations are already set for the Logger.Printf method")
	}

	mmPrintf.mock.funcPrintf = f
	return mmPrintf.mock
}

// Printf implements contracts.Logger
func (mmPrintf *LoggerMock) Printf(format string, args ...any) {
	mm_atomic.AddUint64(&mmPrintf.beforePrintfCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintf.afterPrintfCounter, 1)

	if mmPrintf.inspectFuncPrintf != nil {
		mmPrintf.inspectFuncPrintf(format, args...)
	}

	mm_params := LoggerMockPrintfParams{format, args}

	// Record call args
	mmPrintf.PrintfMock.mutex.Lock()
	mmPrintf.PrintfMock.callArgs = append(mmPrintf.PrintfMock.callArgs, &mm_params)
	mmPrintf.PrintfMock.mutex.Unlock()

	for _, e := range mmPrintf.PrintfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrintf.PrintfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintf.PrintfMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintf.PrintfMock.defaultExpectation.params
		mm_got := LoggerMockPrintfParams{format, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintf.t.Errorf("LoggerMock.Printf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrintf.funcPrintf != nil {
		mmPrintf.funcPrintf(format, args...)
		return
	}
	mmPrintf.t.Fatalf("Unexpected call to LoggerMock.Printf. %v %v", format, args)

}

// PrintfAfterCounter returns a count of finished LoggerMock.Printf invocations
func (mmPrintf *LoggerMock) PrintfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintf.afterPrintfCounter)
}

// PrintfBeforeCounter returns a count of LoggerMock.Printf invocations
func (mmPrintf *LoggerMock) PrintfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintf.beforePrintfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Printf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintf *mLoggerMockPrintf) Calls() []*LoggerMockPrintfParams {
	mmPrintf.mutex.RLock()

	argCopy := make([]*LoggerMockPrintfParams, len(mmPrintf.callArgs))
	copy(argCopy, mmPrintf.callArgs)

	mmPrintf.mutex.RUnlock()

	return argCopy
}

// MinimockPrintfDone returns true if the count of the Printf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPrintfDone() bool {
	for _, e := range m.PrintfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintf != nil && mm_atomic.LoadUint64(&m.afterPrintfCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrintfInspect logs each unmet expectation
func (m *LoggerMock) MinimockPrintfInspect() {
	for _, e := range m.PrintfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Printf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintfCounter) < 1 {
		if m.PrintfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Printf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Printf with params: %#v", *m.PrintfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintf != nil && mm_atomic.LoadUint64(&m.afterPrintfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Printf")
	}
}

type mLoggerMockWarn struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnExpectation
	expectations       []*LoggerMockWarnExpectation

	callArgs []*LoggerMockWarnParams
	mutex    sync.RWMutex
}

// LoggerMockWarnExpectation specifies expectation struct of the Logger.Warn
type LoggerMockWarnExpectation struct {
	mock   *LoggerMock
	params *LoggerMockWarnParams

	Counter uint64
}

// LoggerMockWarnParams contains parameters of the Logger.Warn
type LoggerMockWarnParams struct {
	msg     any
	keyvals []any
}

// Expect sets up expected params for Logger.Warn
func (mmWarn *mLoggerMockWarn) Expect(msg any, keyvals ...any) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	mmWarn.defaultExpectation.params = &LoggerMockWarnParams{msg, keyvals}
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warn
func (mmWarn *mLoggerMockWarn) Inspect(f func(msg any, keyvals ...any)) *mLoggerMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Logger.Warn
func (mmWarn *mLoggerMockWarn) Return() *LoggerMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{mock: mmWarn.mock}
	}

	return mmWarn.mock
}

// Set uses given function f to mock the Logger.Warn method
func (mmWarn *mLoggerMockWarn) Set(f func(msg any, keyvals ...any)) *LoggerMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Logger.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Logger.Warn method")
	}

	mmWarn.mock.funcWarn = f
	return mmWarn.mock
}

// Warn implements contracts.Logger
func (mmWarn *LoggerMock) Warn(msg any, keyvals ...any) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(msg, keyvals...)
	}

	mm_params := LoggerMockWarnParams{msg, keyvals}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, &mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_got := LoggerMockWarnParams{msg, keyvals}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(msg, keyvals...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerMock.Warn. %v %v", msg, keyvals)

}

// WarnAfterCounter returns a count of finished LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerMockWarn) Calls() []*LoggerMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnDone() bool {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warn")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Warn")
	}
}

type mLoggerMockWarnf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnfExpectation
	expectations       []*LoggerMockWarnfExpectation

	callArgs []*LoggerMockWarnfParams
	mutex    sync.RWMutex
}

// LoggerMockWarnfExpectation specifies expectation struct of the Logger.Warnf
type LoggerMockWarnfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockWarnfParams

	Counter uint64
}

// LoggerMockWarnfParams contains parameters of the Logger.Warnf
type LoggerMockWarnfParams struct {
	template string
	a        []any
}

// Expect sets up expected params for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Expect(template string, a ...any) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	mmWarnf.defaultExpectation.params = &LoggerMockWarnfParams{template, a}
	for _, e := range mmWarnf.expectations {
		if minimock.Equal(e.params, mmWarnf.defaultExpectation.params) {
			mmWarnf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarnf.defaultExpectation.params)
		}
	}

	return mmWarnf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Inspect(f func(template string, a ...any)) *mLoggerMockWarnf {
	if mmWarnf.mock.inspectFuncWarnf != nil {
		mmWarnf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warnf")
	}

	mmWarnf.mock.inspectFuncWarnf = f

	return mmWarnf
}

// Return sets up results that will be returned by Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Return() *LoggerMock {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{mock: mmWarnf.mock}
	}

	return mmWarnf.mock
}

// Set uses given function f to mock the Logger.Warnf method
func (mmWarnf *mLoggerMockWarnf) Set(f func(template string, a ...any)) *LoggerMock {
	if mmWarnf.defaultExpectation != nil {
		mmWarnf.mock.t.Fatalf("Default expectation is already set for the Logger.Warnf method")
	}

	if len(mmWarnf.expectations) > 0 {
		mmWarnf.mock.t.Fatalf("Some expectations are already set for the Logger.Warnf method")
	}

	mmWarnf.mock.funcWarnf = f
	return mmWarnf.mock
}

// Warnf implements contracts.Logger
func (mmWarnf *LoggerMock) Warnf(template string, a ...any) {
	mm_atomic.AddUint64(&mmWarnf.beforeWarnfCounter, 1)
	defer mm_atomic.AddUint64(&mmWarnf.afterWarnfCounter, 1)

	if mmWarnf.inspectFuncWarnf != nil {
		mmWarnf.inspectFuncWarnf(template, a...)
	}

	mm_params := LoggerMockWarnfParams{template, a}

	// Record call args
	mmWarnf.WarnfMock.mutex.Lock()
	mmWarnf.WarnfMock.callArgs = append(mmWarnf.WarnfMock.callArgs, &mm_params)
	mmWarnf.WarnfMock.mutex.Unlock()

	for _, e := range mmWarnf.WarnfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarnf.WarnfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarnf.WarnfMock.defaultExpectation.Counter, 1)
		mm_want := mmWarnf.WarnfMock.defaultExpectation.params
		mm_got := LoggerMockWarnfParams{template, a}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarnf.funcWarnf != nil {
		mmWarnf.funcWarnf(template, a...)
		return
	}
	mmWarnf.t.Fatalf("Unexpected call to LoggerMock.Warnf. %v %v", template, a)

}

// WarnfAfterCounter returns a count of finished LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.afterWarnfCounter)
}

// WarnfBeforeCounter returns a count of LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.beforeWarnfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warnf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarnf *mLoggerMockWarnf) Calls() []*LoggerMockWarnfParams {
	mmWarnf.mutex.RLock()

	argCopy := make([]*LoggerMockWarnfParams, len(mmWarnf.callArgs))
	copy(argCopy, mmWarnf.callArgs)

	mmWarnf.mutex.RUnlock()

	return argCopy
}

// MinimockWarnfDone returns true if the count of the Warnf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnfDone() bool {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarnfInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnfInspect() {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		if m.WarnfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warnf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *m.WarnfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Warnf")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDebugInspect()

			m.MinimockDebugfInspect()

			m.MinimockErrorInspect()

			m.MinimockErrorfInspect()

			m.MinimockInfoInspect()

			m.MinimockInfofInspect()

			m.MinimockPrintInspect()

			m.MinimockPrintfInspect()

			m.MinimockWarnInspect()

			m.MinimockWarnfInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockDebugfDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockInfoDone() &&
		m.MinimockInfofDone() &&
		m.MinimockPrintDone() &&
		m.MinimockPrintfDone() &&
		m.MinimockWarnDone() &&
		m.MinimockWarnfDone()
}
