package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/evg4b/uncors/internal/server.Listener -o ./listener_mock.go -n ListenerMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ListenerMock implements server.Listener
type ListenerMock struct {
	t minimock.Tester

	funcListenAndServe          func() (err error)
	inspectFuncListenAndServe   func()
	afterListenAndServeCounter  uint64
	beforeListenAndServeCounter uint64
	ListenAndServeMock          mListenerMockListenAndServe

	funcListenAndServeTLS          func(certFile string, keyFile string) (err error)
	inspectFuncListenAndServeTLS   func(certFile string, keyFile string)
	afterListenAndServeTLSCounter  uint64
	beforeListenAndServeTLSCounter uint64
	ListenAndServeTLSMock          mListenerMockListenAndServeTLS

	funcShutdown          func(ctx context.Context) (err error)
	inspectFuncShutdown   func(ctx context.Context)
	afterShutdownCounter  uint64
	beforeShutdownCounter uint64
	ShutdownMock          mListenerMockShutdown
}

// NewListenerMock returns a mock for server.Listener
func NewListenerMock(t minimock.Tester) *ListenerMock {
	m := &ListenerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ListenAndServeMock = mListenerMockListenAndServe{mock: m}

	m.ListenAndServeTLSMock = mListenerMockListenAndServeTLS{mock: m}
	m.ListenAndServeTLSMock.callArgs = []*ListenerMockListenAndServeTLSParams{}

	m.ShutdownMock = mListenerMockShutdown{mock: m}
	m.ShutdownMock.callArgs = []*ListenerMockShutdownParams{}

	return m
}

type mListenerMockListenAndServe struct {
	mock               *ListenerMock
	defaultExpectation *ListenerMockListenAndServeExpectation
	expectations       []*ListenerMockListenAndServeExpectation
}

// ListenerMockListenAndServeExpectation specifies expectation struct of the Listener.ListenAndServe
type ListenerMockListenAndServeExpectation struct {
	mock *ListenerMock

	results *ListenerMockListenAndServeResults
	Counter uint64
}

// ListenerMockListenAndServeResults contains results of the Listener.ListenAndServe
type ListenerMockListenAndServeResults struct {
	err error
}

// Expect sets up expected params for Listener.ListenAndServe
func (mmListenAndServe *mListenerMockListenAndServe) Expect() *mListenerMockListenAndServe {
	if mmListenAndServe.mock.funcListenAndServe != nil {
		mmListenAndServe.mock.t.Fatalf("ListenerMock.ListenAndServe mock is already set by Set")
	}

	if mmListenAndServe.defaultExpectation == nil {
		mmListenAndServe.defaultExpectation = &ListenerMockListenAndServeExpectation{}
	}

	return mmListenAndServe
}

// Inspect accepts an inspector function that has same arguments as the Listener.ListenAndServe
func (mmListenAndServe *mListenerMockListenAndServe) Inspect(f func()) *mListenerMockListenAndServe {
	if mmListenAndServe.mock.inspectFuncListenAndServe != nil {
		mmListenAndServe.mock.t.Fatalf("Inspect function is already set for ListenerMock.ListenAndServe")
	}

	mmListenAndServe.mock.inspectFuncListenAndServe = f

	return mmListenAndServe
}

// Return sets up results that will be returned by Listener.ListenAndServe
func (mmListenAndServe *mListenerMockListenAndServe) Return(err error) *ListenerMock {
	if mmListenAndServe.mock.funcListenAndServe != nil {
		mmListenAndServe.mock.t.Fatalf("ListenerMock.ListenAndServe mock is already set by Set")
	}

	if mmListenAndServe.defaultExpectation == nil {
		mmListenAndServe.defaultExpectation = &ListenerMockListenAndServeExpectation{mock: mmListenAndServe.mock}
	}
	mmListenAndServe.defaultExpectation.results = &ListenerMockListenAndServeResults{err}
	return mmListenAndServe.mock
}

//Set uses given function f to mock the Listener.ListenAndServe method
func (mmListenAndServe *mListenerMockListenAndServe) Set(f func() (err error)) *ListenerMock {
	if mmListenAndServe.defaultExpectation != nil {
		mmListenAndServe.mock.t.Fatalf("Default expectation is already set for the Listener.ListenAndServe method")
	}

	if len(mmListenAndServe.expectations) > 0 {
		mmListenAndServe.mock.t.Fatalf("Some expectations are already set for the Listener.ListenAndServe method")
	}

	mmListenAndServe.mock.funcListenAndServe = f
	return mmListenAndServe.mock
}

// ListenAndServe implements server.Listener
func (mmListenAndServe *ListenerMock) ListenAndServe() (err error) {
	mm_atomic.AddUint64(&mmListenAndServe.beforeListenAndServeCounter, 1)
	defer mm_atomic.AddUint64(&mmListenAndServe.afterListenAndServeCounter, 1)

	if mmListenAndServe.inspectFuncListenAndServe != nil {
		mmListenAndServe.inspectFuncListenAndServe()
	}

	if mmListenAndServe.ListenAndServeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListenAndServe.ListenAndServeMock.defaultExpectation.Counter, 1)

		mm_results := mmListenAndServe.ListenAndServeMock.defaultExpectation.results
		if mm_results == nil {
			mmListenAndServe.t.Fatal("No results are set for the ListenerMock.ListenAndServe")
		}
		return (*mm_results).err
	}
	if mmListenAndServe.funcListenAndServe != nil {
		return mmListenAndServe.funcListenAndServe()
	}
	mmListenAndServe.t.Fatalf("Unexpected call to ListenerMock.ListenAndServe.")
	return
}

// ListenAndServeAfterCounter returns a count of finished ListenerMock.ListenAndServe invocations
func (mmListenAndServe *ListenerMock) ListenAndServeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenAndServe.afterListenAndServeCounter)
}

// ListenAndServeBeforeCounter returns a count of ListenerMock.ListenAndServe invocations
func (mmListenAndServe *ListenerMock) ListenAndServeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenAndServe.beforeListenAndServeCounter)
}

// MinimockListenAndServeDone returns true if the count of the ListenAndServe invocations corresponds
// the number of defined expectations
func (m *ListenerMock) MinimockListenAndServeDone() bool {
	for _, e := range m.ListenAndServeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListenAndServeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListenAndServeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenAndServe != nil && mm_atomic.LoadUint64(&m.afterListenAndServeCounter) < 1 {
		return false
	}
	return true
}

// MinimockListenAndServeInspect logs each unmet expectation
func (m *ListenerMock) MinimockListenAndServeInspect() {
	for _, e := range m.ListenAndServeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ListenerMock.ListenAndServe")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListenAndServeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListenAndServeCounter) < 1 {
		m.t.Error("Expected call to ListenerMock.ListenAndServe")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenAndServe != nil && mm_atomic.LoadUint64(&m.afterListenAndServeCounter) < 1 {
		m.t.Error("Expected call to ListenerMock.ListenAndServe")
	}
}

type mListenerMockListenAndServeTLS struct {
	mock               *ListenerMock
	defaultExpectation *ListenerMockListenAndServeTLSExpectation
	expectations       []*ListenerMockListenAndServeTLSExpectation

	callArgs []*ListenerMockListenAndServeTLSParams
	mutex    sync.RWMutex
}

// ListenerMockListenAndServeTLSExpectation specifies expectation struct of the Listener.ListenAndServeTLS
type ListenerMockListenAndServeTLSExpectation struct {
	mock    *ListenerMock
	params  *ListenerMockListenAndServeTLSParams
	results *ListenerMockListenAndServeTLSResults
	Counter uint64
}

// ListenerMockListenAndServeTLSParams contains parameters of the Listener.ListenAndServeTLS
type ListenerMockListenAndServeTLSParams struct {
	certFile string
	keyFile  string
}

// ListenerMockListenAndServeTLSResults contains results of the Listener.ListenAndServeTLS
type ListenerMockListenAndServeTLSResults struct {
	err error
}

// Expect sets up expected params for Listener.ListenAndServeTLS
func (mmListenAndServeTLS *mListenerMockListenAndServeTLS) Expect(certFile string, keyFile string) *mListenerMockListenAndServeTLS {
	if mmListenAndServeTLS.mock.funcListenAndServeTLS != nil {
		mmListenAndServeTLS.mock.t.Fatalf("ListenerMock.ListenAndServeTLS mock is already set by Set")
	}

	if mmListenAndServeTLS.defaultExpectation == nil {
		mmListenAndServeTLS.defaultExpectation = &ListenerMockListenAndServeTLSExpectation{}
	}

	mmListenAndServeTLS.defaultExpectation.params = &ListenerMockListenAndServeTLSParams{certFile, keyFile}
	for _, e := range mmListenAndServeTLS.expectations {
		if minimock.Equal(e.params, mmListenAndServeTLS.defaultExpectation.params) {
			mmListenAndServeTLS.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListenAndServeTLS.defaultExpectation.params)
		}
	}

	return mmListenAndServeTLS
}

// Inspect accepts an inspector function that has same arguments as the Listener.ListenAndServeTLS
func (mmListenAndServeTLS *mListenerMockListenAndServeTLS) Inspect(f func(certFile string, keyFile string)) *mListenerMockListenAndServeTLS {
	if mmListenAndServeTLS.mock.inspectFuncListenAndServeTLS != nil {
		mmListenAndServeTLS.mock.t.Fatalf("Inspect function is already set for ListenerMock.ListenAndServeTLS")
	}

	mmListenAndServeTLS.mock.inspectFuncListenAndServeTLS = f

	return mmListenAndServeTLS
}

// Return sets up results that will be returned by Listener.ListenAndServeTLS
func (mmListenAndServeTLS *mListenerMockListenAndServeTLS) Return(err error) *ListenerMock {
	if mmListenAndServeTLS.mock.funcListenAndServeTLS != nil {
		mmListenAndServeTLS.mock.t.Fatalf("ListenerMock.ListenAndServeTLS mock is already set by Set")
	}

	if mmListenAndServeTLS.defaultExpectation == nil {
		mmListenAndServeTLS.defaultExpectation = &ListenerMockListenAndServeTLSExpectation{mock: mmListenAndServeTLS.mock}
	}
	mmListenAndServeTLS.defaultExpectation.results = &ListenerMockListenAndServeTLSResults{err}
	return mmListenAndServeTLS.mock
}

//Set uses given function f to mock the Listener.ListenAndServeTLS method
func (mmListenAndServeTLS *mListenerMockListenAndServeTLS) Set(f func(certFile string, keyFile string) (err error)) *ListenerMock {
	if mmListenAndServeTLS.defaultExpectation != nil {
		mmListenAndServeTLS.mock.t.Fatalf("Default expectation is already set for the Listener.ListenAndServeTLS method")
	}

	if len(mmListenAndServeTLS.expectations) > 0 {
		mmListenAndServeTLS.mock.t.Fatalf("Some expectations are already set for the Listener.ListenAndServeTLS method")
	}

	mmListenAndServeTLS.mock.funcListenAndServeTLS = f
	return mmListenAndServeTLS.mock
}

// When sets expectation for the Listener.ListenAndServeTLS which will trigger the result defined by the following
// Then helper
func (mmListenAndServeTLS *mListenerMockListenAndServeTLS) When(certFile string, keyFile string) *ListenerMockListenAndServeTLSExpectation {
	if mmListenAndServeTLS.mock.funcListenAndServeTLS != nil {
		mmListenAndServeTLS.mock.t.Fatalf("ListenerMock.ListenAndServeTLS mock is already set by Set")
	}

	expectation := &ListenerMockListenAndServeTLSExpectation{
		mock:   mmListenAndServeTLS.mock,
		params: &ListenerMockListenAndServeTLSParams{certFile, keyFile},
	}
	mmListenAndServeTLS.expectations = append(mmListenAndServeTLS.expectations, expectation)
	return expectation
}

// Then sets up Listener.ListenAndServeTLS return parameters for the expectation previously defined by the When method
func (e *ListenerMockListenAndServeTLSExpectation) Then(err error) *ListenerMock {
	e.results = &ListenerMockListenAndServeTLSResults{err}
	return e.mock
}

// ListenAndServeTLS implements server.Listener
func (mmListenAndServeTLS *ListenerMock) ListenAndServeTLS(certFile string, keyFile string) (err error) {
	mm_atomic.AddUint64(&mmListenAndServeTLS.beforeListenAndServeTLSCounter, 1)
	defer mm_atomic.AddUint64(&mmListenAndServeTLS.afterListenAndServeTLSCounter, 1)

	if mmListenAndServeTLS.inspectFuncListenAndServeTLS != nil {
		mmListenAndServeTLS.inspectFuncListenAndServeTLS(certFile, keyFile)
	}

	mm_params := &ListenerMockListenAndServeTLSParams{certFile, keyFile}

	// Record call args
	mmListenAndServeTLS.ListenAndServeTLSMock.mutex.Lock()
	mmListenAndServeTLS.ListenAndServeTLSMock.callArgs = append(mmListenAndServeTLS.ListenAndServeTLSMock.callArgs, mm_params)
	mmListenAndServeTLS.ListenAndServeTLSMock.mutex.Unlock()

	for _, e := range mmListenAndServeTLS.ListenAndServeTLSMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListenAndServeTLS.ListenAndServeTLSMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListenAndServeTLS.ListenAndServeTLSMock.defaultExpectation.Counter, 1)
		mm_want := mmListenAndServeTLS.ListenAndServeTLSMock.defaultExpectation.params
		mm_got := ListenerMockListenAndServeTLSParams{certFile, keyFile}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListenAndServeTLS.t.Errorf("ListenerMock.ListenAndServeTLS got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListenAndServeTLS.ListenAndServeTLSMock.defaultExpectation.results
		if mm_results == nil {
			mmListenAndServeTLS.t.Fatal("No results are set for the ListenerMock.ListenAndServeTLS")
		}
		return (*mm_results).err
	}
	if mmListenAndServeTLS.funcListenAndServeTLS != nil {
		return mmListenAndServeTLS.funcListenAndServeTLS(certFile, keyFile)
	}
	mmListenAndServeTLS.t.Fatalf("Unexpected call to ListenerMock.ListenAndServeTLS. %v %v", certFile, keyFile)
	return
}

// ListenAndServeTLSAfterCounter returns a count of finished ListenerMock.ListenAndServeTLS invocations
func (mmListenAndServeTLS *ListenerMock) ListenAndServeTLSAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenAndServeTLS.afterListenAndServeTLSCounter)
}

// ListenAndServeTLSBeforeCounter returns a count of ListenerMock.ListenAndServeTLS invocations
func (mmListenAndServeTLS *ListenerMock) ListenAndServeTLSBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenAndServeTLS.beforeListenAndServeTLSCounter)
}

// Calls returns a list of arguments used in each call to ListenerMock.ListenAndServeTLS.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListenAndServeTLS *mListenerMockListenAndServeTLS) Calls() []*ListenerMockListenAndServeTLSParams {
	mmListenAndServeTLS.mutex.RLock()

	argCopy := make([]*ListenerMockListenAndServeTLSParams, len(mmListenAndServeTLS.callArgs))
	copy(argCopy, mmListenAndServeTLS.callArgs)

	mmListenAndServeTLS.mutex.RUnlock()

	return argCopy
}

// MinimockListenAndServeTLSDone returns true if the count of the ListenAndServeTLS invocations corresponds
// the number of defined expectations
func (m *ListenerMock) MinimockListenAndServeTLSDone() bool {
	for _, e := range m.ListenAndServeTLSMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListenAndServeTLSMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListenAndServeTLSCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenAndServeTLS != nil && mm_atomic.LoadUint64(&m.afterListenAndServeTLSCounter) < 1 {
		return false
	}
	return true
}

// MinimockListenAndServeTLSInspect logs each unmet expectation
func (m *ListenerMock) MinimockListenAndServeTLSInspect() {
	for _, e := range m.ListenAndServeTLSMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ListenerMock.ListenAndServeTLS with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListenAndServeTLSMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListenAndServeTLSCounter) < 1 {
		if m.ListenAndServeTLSMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ListenerMock.ListenAndServeTLS")
		} else {
			m.t.Errorf("Expected call to ListenerMock.ListenAndServeTLS with params: %#v", *m.ListenAndServeTLSMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenAndServeTLS != nil && mm_atomic.LoadUint64(&m.afterListenAndServeTLSCounter) < 1 {
		m.t.Error("Expected call to ListenerMock.ListenAndServeTLS")
	}
}

type mListenerMockShutdown struct {
	mock               *ListenerMock
	defaultExpectation *ListenerMockShutdownExpectation
	expectations       []*ListenerMockShutdownExpectation

	callArgs []*ListenerMockShutdownParams
	mutex    sync.RWMutex
}

// ListenerMockShutdownExpectation specifies expectation struct of the Listener.Shutdown
type ListenerMockShutdownExpectation struct {
	mock    *ListenerMock
	params  *ListenerMockShutdownParams
	results *ListenerMockShutdownResults
	Counter uint64
}

// ListenerMockShutdownParams contains parameters of the Listener.Shutdown
type ListenerMockShutdownParams struct {
	ctx context.Context
}

// ListenerMockShutdownResults contains results of the Listener.Shutdown
type ListenerMockShutdownResults struct {
	err error
}

// Expect sets up expected params for Listener.Shutdown
func (mmShutdown *mListenerMockShutdown) Expect(ctx context.Context) *mListenerMockShutdown {
	if mmShutdown.mock.funcShutdown != nil {
		mmShutdown.mock.t.Fatalf("ListenerMock.Shutdown mock is already set by Set")
	}

	if mmShutdown.defaultExpectation == nil {
		mmShutdown.defaultExpectation = &ListenerMockShutdownExpectation{}
	}

	mmShutdown.defaultExpectation.params = &ListenerMockShutdownParams{ctx}
	for _, e := range mmShutdown.expectations {
		if minimock.Equal(e.params, mmShutdown.defaultExpectation.params) {
			mmShutdown.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShutdown.defaultExpectation.params)
		}
	}

	return mmShutdown
}

// Inspect accepts an inspector function that has same arguments as the Listener.Shutdown
func (mmShutdown *mListenerMockShutdown) Inspect(f func(ctx context.Context)) *mListenerMockShutdown {
	if mmShutdown.mock.inspectFuncShutdown != nil {
		mmShutdown.mock.t.Fatalf("Inspect function is already set for ListenerMock.Shutdown")
	}

	mmShutdown.mock.inspectFuncShutdown = f

	return mmShutdown
}

// Return sets up results that will be returned by Listener.Shutdown
func (mmShutdown *mListenerMockShutdown) Return(err error) *ListenerMock {
	if mmShutdown.mock.funcShutdown != nil {
		mmShutdown.mock.t.Fatalf("ListenerMock.Shutdown mock is already set by Set")
	}

	if mmShutdown.defaultExpectation == nil {
		mmShutdown.defaultExpectation = &ListenerMockShutdownExpectation{mock: mmShutdown.mock}
	}
	mmShutdown.defaultExpectation.results = &ListenerMockShutdownResults{err}
	return mmShutdown.mock
}

//Set uses given function f to mock the Listener.Shutdown method
func (mmShutdown *mListenerMockShutdown) Set(f func(ctx context.Context) (err error)) *ListenerMock {
	if mmShutdown.defaultExpectation != nil {
		mmShutdown.mock.t.Fatalf("Default expectation is already set for the Listener.Shutdown method")
	}

	if len(mmShutdown.expectations) > 0 {
		mmShutdown.mock.t.Fatalf("Some expectations are already set for the Listener.Shutdown method")
	}

	mmShutdown.mock.funcShutdown = f
	return mmShutdown.mock
}

// When sets expectation for the Listener.Shutdown which will trigger the result defined by the following
// Then helper
func (mmShutdown *mListenerMockShutdown) When(ctx context.Context) *ListenerMockShutdownExpectation {
	if mmShutdown.mock.funcShutdown != nil {
		mmShutdown.mock.t.Fatalf("ListenerMock.Shutdown mock is already set by Set")
	}

	expectation := &ListenerMockShutdownExpectation{
		mock:   mmShutdown.mock,
		params: &ListenerMockShutdownParams{ctx},
	}
	mmShutdown.expectations = append(mmShutdown.expectations, expectation)
	return expectation
}

// Then sets up Listener.Shutdown return parameters for the expectation previously defined by the When method
func (e *ListenerMockShutdownExpectation) Then(err error) *ListenerMock {
	e.results = &ListenerMockShutdownResults{err}
	return e.mock
}

// Shutdown implements server.Listener
func (mmShutdown *ListenerMock) Shutdown(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmShutdown.beforeShutdownCounter, 1)
	defer mm_atomic.AddUint64(&mmShutdown.afterShutdownCounter, 1)

	if mmShutdown.inspectFuncShutdown != nil {
		mmShutdown.inspectFuncShutdown(ctx)
	}

	mm_params := &ListenerMockShutdownParams{ctx}

	// Record call args
	mmShutdown.ShutdownMock.mutex.Lock()
	mmShutdown.ShutdownMock.callArgs = append(mmShutdown.ShutdownMock.callArgs, mm_params)
	mmShutdown.ShutdownMock.mutex.Unlock()

	for _, e := range mmShutdown.ShutdownMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmShutdown.ShutdownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShutdown.ShutdownMock.defaultExpectation.Counter, 1)
		mm_want := mmShutdown.ShutdownMock.defaultExpectation.params
		mm_got := ListenerMockShutdownParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShutdown.t.Errorf("ListenerMock.Shutdown got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShutdown.ShutdownMock.defaultExpectation.results
		if mm_results == nil {
			mmShutdown.t.Fatal("No results are set for the ListenerMock.Shutdown")
		}
		return (*mm_results).err
	}
	if mmShutdown.funcShutdown != nil {
		return mmShutdown.funcShutdown(ctx)
	}
	mmShutdown.t.Fatalf("Unexpected call to ListenerMock.Shutdown. %v", ctx)
	return
}

// ShutdownAfterCounter returns a count of finished ListenerMock.Shutdown invocations
func (mmShutdown *ListenerMock) ShutdownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShutdown.afterShutdownCounter)
}

// ShutdownBeforeCounter returns a count of ListenerMock.Shutdown invocations
func (mmShutdown *ListenerMock) ShutdownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShutdown.beforeShutdownCounter)
}

// Calls returns a list of arguments used in each call to ListenerMock.Shutdown.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShutdown *mListenerMockShutdown) Calls() []*ListenerMockShutdownParams {
	mmShutdown.mutex.RLock()

	argCopy := make([]*ListenerMockShutdownParams, len(mmShutdown.callArgs))
	copy(argCopy, mmShutdown.callArgs)

	mmShutdown.mutex.RUnlock()

	return argCopy
}

// MinimockShutdownDone returns true if the count of the Shutdown invocations corresponds
// the number of defined expectations
func (m *ListenerMock) MinimockShutdownDone() bool {
	for _, e := range m.ShutdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShutdownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShutdownCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShutdown != nil && mm_atomic.LoadUint64(&m.afterShutdownCounter) < 1 {
		return false
	}
	return true
}

// MinimockShutdownInspect logs each unmet expectation
func (m *ListenerMock) MinimockShutdownInspect() {
	for _, e := range m.ShutdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ListenerMock.Shutdown with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShutdownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShutdownCounter) < 1 {
		if m.ShutdownMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ListenerMock.Shutdown")
		} else {
			m.t.Errorf("Expected call to ListenerMock.Shutdown with params: %#v", *m.ShutdownMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShutdown != nil && mm_atomic.LoadUint64(&m.afterShutdownCounter) < 1 {
		m.t.Error("Expected call to ListenerMock.Shutdown")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ListenerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockListenAndServeInspect()

		m.MinimockListenAndServeTLSInspect()

		m.MinimockShutdownInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ListenerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ListenerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockListenAndServeDone() &&
		m.MinimockListenAndServeTLSDone() &&
		m.MinimockShutdownDone()
}
