# Script Handler

The script handler allows you to implement custom request handling logic using scripts. This provides maximum flexibility for generating dynamic responses, implementing custom business logic, or creating complex API simulations during development and testing.

**Key features:**

- **Inline or file-based scripts**: Define script code directly in configuration or load from external files
- **Request access**: Full access to request properties (method, URL, headers, body, query parameters)
- **Response control**: Set status codes, headers, and body content from script
- **Standard libraries**: Use math, string, table, and OS libraries
- **Path-based matching**: Define which URLs to handle with scripts
- **Method-specific**: Target specific HTTP methods (GET, POST, etc.)
- **Query parameter filtering**: Match requests with specific query strings
- **Header matching**: Filter by HTTP headers

**Configuration structure:**

```yaml
mappings:
  - from: ...
    to: ...
    scripts:
      - path: /api/custom
        method: POST
        queries:
          param1: value1
        headers:
          Content-Type: application/json
        script: |
          response.status = 200
          response.body = '{"message": "Hello from script"}'
          response.headers["Content-Type"] = "application/json"
        file: /path/to/script.lua  # Alternative to inline script
```

# Request Matching

Configure which requests should be handled by the script:

## Path (Required)

Defines the URL path to handle. Supports static paths and variable segments.

**Examples:**

```yaml
path: /api/custom             # Static path
path: /users/{id}             # Variable segment
path: /posts/{postId}/data    # Multiple variables
```

Variable segments (e.g., `{id}`) match any value in that position. A request to `/users/123` matches `/users/{id}`.

## Method (Optional)

Specifies the HTTP method to match.

| Property | Type   | Default | Description                                                |
| -------- | ------ | ------- | ---------------------------------------------------------- |
| `method` | string | Any     | HTTP method: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, etc. |

If omitted, the script matches all HTTP methods.

## Query Parameters (Optional)

Match requests with specific query string parameters.

```yaml
queries:
  param1: value1
  param2: value2
```

If omitted, all query parameter combinations are matched.

## Headers (Optional)

Match requests with specific HTTP headers.

```yaml
headers:
  Content-Type: application/json
  Authorization: Bearer token123
```

If omitted, all header combinations are matched.

# Script Configuration

Define the script to execute when a request is matched.

## Script Properties

| Property | Type   | Required      | Description                                |
| -------- | ------ | ------------- | ------------------------------------------ |
| `script` | string | Conditional\* | Inline script code                     |
| `file`   | string | Conditional\* | Path to file containing script         |

**\*Either `script` or `file` must be specified, but not both.**

## Inline Script

Define script code directly in the configuration:

```yaml
scripts:
  - path: /api/greeting
    method: GET
    script: |
      local name = request.query_params["name"] or "World"
      response.status = 200
      response.body = '{"message": "Hello, ' .. name .. '"}'
      response.headers["Content-Type"] = "application/json"
```

## File-based Script

Load script code from an external file:

```yaml
scripts:
  - path: /api/calculate
    method: POST
    file: ~/scripts/calculator.lua
```

**File example (`~/scripts/calculator.lua`):**

```lua
-- Access request body
local body = request.body

-- Parse and process (example)
local result = 42  -- Your calculation logic here

-- Set response
response.status = 200
response.body = '{"result": ' .. result .. '}'
response.headers["Content-Type"] = "application/json"
```

# Request Object

The `request` object provides access to incoming HTTP request properties.

## Request Properties

| Property        | Type   | Description                                     | Example                             |
| --------------- | ------ | ----------------------------------------------- | ----------------------------------- |
| `method`        | string | HTTP method                                     | `"GET"`, `"POST"`, etc.             |
| `url`           | string | Full request URL                                | `"http://localhost/api/users?id=1"` |
| `path`          | string | URL path                                        | `"/api/users"`                      |
| `query`         | string | Raw query string                                | `"id=1&name=test"`                  |
| `host`          | string | Host header value                               | `"localhost:8080"`                  |
| `remote_addr`   | string | Client IP address                               | `"127.0.0.1:12345"`                 |
| `body`          | string | Request body content                            | `'{"data": "value"}'`               |
| `headers`       | table  | Request headers (table with string keys/values) | `request.headers["Content-Type"]`   |
| `query_params`  | table  | Parsed query parameters                         | `request.query_params["id"]`        |
| `path_params`   | table  | Path parameters from route                      | `request.path_params["id"]`         |

## Accessing Request Data

### HTTP Method

```lua
if request.method == "GET" then
    response.body = "This is a GET request"
end
```

### URL and Path

```lua
response.body = "You accessed: " .. request.path
```

### Headers

```lua
local contentType = request.headers["Content-Type"]
local userAgent = request.headers["User-Agent"]

response.body = "Content-Type: " .. (contentType or "not set")
```

### Query Parameters

```lua
local id = request.query_params["id"]
local filter = request.query_params["filter"]

if id then
    response.body = '{"id": ' .. id .. '}'
else
    response.status = 400
    response.body = '{"error": "Missing id parameter"}'
end
```

### Path Parameters

Path parameters are extracted from the URL route pattern using wildcards (`{param}`). For example, if your route is `/users/{id}/posts/{postId}`, you can access these parameters:

```lua
local userId = request.path_params["id"]
local postId = request.path_params["postId"]

if userId and postId then
    response.body = '{"user": ' .. userId .. ', "post": ' .. postId .. '}'
else
    response.status = 400
    response.body = '{"error": "Missing path parameters"}'
end
```

**Configuration example:**

```yaml
scripts:
  - path: /users/{id}/posts/{postId}
    method: GET
    script: |
      local userId = request.path_params["id"]
      local postId = request.path_params["postId"]
      response.status = 200
      response.body = '{"user": "' .. userId .. '", "post": "' .. postId .. '"}'
      response.headers["Content-Type"] = "application/json"
```

### Request Body

```lua
local body = request.body

-- Simple body echo
response.body = "You sent: " .. body

-- Or process the body
if string.find(body, "error") then
    response.status = 500
else
    response.status = 200
end
```

### Host Information

```lua
if request.host == "api.example.com" then
    response.body = "Production API"
else
    response.body = "Development API"
end
```

# Response Object

The `response` object controls the HTTP response returned to the client.

## Response Properties

| Property  | Type   | Default | Description                                    |
| --------- | ------ | ------- | ---------------------------------------------- |
| `status`  | number | 200     | HTTP status code                               |
| `body`    | string | `""`    | Response body content                          |
| `headers` | table  | `{}`    | Response headers (table with string keys/values) |

## Setting Response Properties

### Status Code

```lua
response.status = 201  -- Created
response.status = 404  -- Not Found
response.status = 500  -- Internal Server Error
```

### Response Body

```lua
-- Simple text
response.body = "Hello, World!"

-- JSON (as string)
response.body = '{"message": "Success", "code": 200}'

-- Constructed dynamically
local name = "Alice"
response.body = '{"name": "' .. name .. '"}'
```

### Response Headers

```lua
-- Set Content-Type
response.headers["Content-Type"] = "application/json"

-- Set custom headers
response.headers["X-Custom-Header"] = "CustomValue"
response.headers["X-Request-ID"] = "12345"

-- Set cache control
response.headers["Cache-Control"] = "no-cache"
```

### Complete Example

```lua
local math = require("math")
local string = require("string")

-- Get query parameters
local min = tonumber(request.query_params["min"]) or 1
local max = tonumber(request.query_params["max"]) or 100

-- Generate random number
math.randomseed(os.time())
local random = math.random(min, max)

-- Build response
response.status = 200
response.body = '{"random": ' .. random .. ', "min": ' .. min .. ', "max": ' .. max .. '}'
response.headers["Content-Type"] = "application/json"
response.headers["X-Generated-At"] = os.date("%Y-%m-%d %H:%M:%S")
```

# Available Libraries

The script handler provides access to standard libraries:

## Math Library

Mathematical functions for calculations.

```lua
local math = require("math")

-- Random numbers
local random = math.random(1, 100)
math.randomseed(os.time())

-- Rounding
local rounded = math.floor(3.7)  -- 3
local ceiling = math.ceil(3.2)   -- 4

-- Trigonometry
local sine = math.sin(1.5)
local cosine = math.cos(1.5)

-- Constants
local pi = math.pi
local huge = math.huge
```

## String Library

String manipulation and formatting.

```lua
local string = require("string")

-- Case conversion
local upper = string.upper("hello")     -- "HELLO"
local lower = string.lower("WORLD")     -- "world"

-- Substring
local sub = string.sub("Hello", 1, 3)   -- "Hel"

-- Find and replace
local pos = string.find("Hello World", "World")
local replaced = string.gsub("Hello World", "World", "Lua")

-- String length
local len = string.len("Hello")         -- 5

-- Formatting
local formatted = string.format("Value: %d", 42)
```

## Table Library

Table (array/dictionary) operations.

```lua
local table = require("table")

-- Array operations
local items = {"apple", "banana", "cherry"}
table.insert(items, "date")              -- Add to end
table.remove(items, 1)                   -- Remove first item

-- Concatenation
local joined = table.concat(items, ", ") -- "banana, cherry, date"

-- Sorting
table.sort(items)
```

## OS Library

Limited OS and time functions.

```lua
local os = require("os")

-- Time
local timestamp = os.time()
local formatted = os.date("%Y-%m-%d %H:%M:%S")
local utc = os.date("!%Y-%m-%d %H:%M:%S")  -- UTC

-- Date components
local components = os.date("*t")
-- components.year, components.month, components.day, etc.
```

# Complete Examples

## Simple API Endpoint

```yaml
scripts:
  - path: /api/health
    method: GET
    script: |
      response.status = 200
      response.body = '{"status": "healthy", "timestamp": "' .. os.date("%Y-%m-%d %H:%M:%S") .. '"}'
      response.headers["Content-Type"] = "application/json"
```

## Dynamic User API

```yaml
scripts:
  - path: /api/users/{id}
    method: GET
    script: |
      local userId = request.query_params["id"] or "unknown"

      response.status = 200
      response.body = '{' ..
        '"id": "' .. userId .. '",' ..
        '"name": "User ' .. userId .. '",' ..
        '"email": "user' .. userId .. '@example.com"' ..
      '}'
      response.headers["Content-Type"] = "application/json"
```

## Calculator API

```yaml
scripts:
  - path: /api/calculate
    method: POST
    script: |
      local math = require("math")

      -- Get operation from query params
      local op = request.query_params["operation"]

      if op == "random" then
        local min = tonumber(request.query_params["min"]) or 1
        local max = tonumber(request.query_params["max"]) or 100
        math.randomseed(os.time())
        local result = math.random(min, max)

        response.status = 200
        response.body = '{"result": ' .. result .. '}'
      elseif op == "sqrt" then
        local value = tonumber(request.query_params["value"]) or 0
        local result = math.sqrt(value)

        response.status = 200
        response.body = '{"result": ' .. result .. '}'
      else
        response.status = 400
        response.body = '{"error": "Unknown operation"}'
      end

      response.headers["Content-Type"] = "application/json"
```

## Request Echo Service

```yaml
scripts:
  - path: /api/echo
    script: |
      response.status = 200
      response.body = '{' ..
        '"method": "' .. request.method .. '",' ..
        '"path": "' .. request.path .. '",' ..
        '"query": "' .. request.query .. '",' ..
        '"body": "' .. request.body .. '",' ..
        '"host": "' .. request.host .. '"' ..
      '}'
      response.headers["Content-Type"] = "application/json"
```

## Conditional Response Based on Headers

```yaml
scripts:
  - path: /api/data
    method: GET
    script: |
      local authHeader = request.headers["Authorization"]

      if authHeader and string.find(authHeader, "Bearer ") then
        response.status = 200
        response.body = '{"data": "Secret information", "authorized": true}'
      else
        response.status = 401
        response.body = '{"error": "Unauthorized", "authorized": false}'
        response.headers["WWW-Authenticate"] = 'Bearer realm="API"'
      end

      response.headers["Content-Type"] = "application/json"
```

# CORS Headers

CORS headers are automatically added to all script responses. You can override them by setting custom header values in your script:

```lua
-- CORS headers are added automatically, but you can override them
response.headers["Access-Control-Allow-Origin"] = "https://example.com"
response.headers["Access-Control-Allow-Methods"] = "GET, POST"
response.headers["Access-Control-Allow-Headers"] = "Content-Type, Authorization"
```

# Error Handling

If your script encounters an error, the handler will return a 500 Internal Server Error response automatically. Common errors include:

- **Script not defined**: Neither `script` nor `file` is specified
- **Both script and file defined**: Only one should be specified
- **File not found**: The specified script file doesn't exist
- **Script syntax error**: Invalid script syntax in your script
- **Script runtime error**: Error during script execution (e.g., accessing nil values)

**Best practices:**

```lua
-- Check for nil values before accessing
if request.query_params["id"] then
    local id = request.query_params["id"]
    -- Use id safely
else
    response.status = 400
    response.body = '{"error": "Missing id parameter"}'
end

-- Use pcall for error handling
local success, result = pcall(function()
    -- Your code that might error
    return someFunction()
end)

if not success then
    response.status = 500
    response.body = '{"error": "Internal error"}'
end
```

# Tips and Best Practices

1. **Keep scripts simple**: scripts are executed for each request, so keep logic lightweight
2. **Use file-based scripts for complex logic**: Easier to test and maintain
3. **Validate input**: Always validate query parameters and headers before using them
4. **Set Content-Type**: Always set the appropriate Content-Type header for your response
5. **Handle errors gracefully**: Check for nil values and provide meaningful error messages
6. **Use libraries**: Leverage math, string, and table libraries for common operations
7. **Test scripts separately**: scripts can be tested independently before integration
8. **Escape JSON strings**: Be careful with quotes when building JSON strings dynamically

# Comparison with Mock Handler

| Feature | Script Handler | Mock Handler |
|---------|-------------------|--------------|
| **Flexibility** | Full control with script code | Pre-defined response types |
| **Dynamic content** | Yes, fully programmable | Limited to fake data schemas |
| **Request access** | Full access to all request properties | No request access |
| **Complex logic** | Yes, use any script code | No logic, configuration-only |
| **Learning curve** | Requires scripting knowledge | Simple YAML configuration |
| **Use case** | Custom business logic, complex API simulation | Simple mocking, fake data generation |

Choose the **Script Handler** when you need:
- Custom business logic
- Request-dependent responses
- Complex data transformations
- Conditional responses based on request data

Choose the **Mock Handler** when you need:
- Simple static responses
- Quick fake data generation
- No custom logic required
